# -*- mode: Org; org-use-property-inheritance: t -*-

#+STARTUP: overview
#+FILETAGS: :emacs:



#+title:Mirage
#+PROPERTY: header-args:emacs-lisp :results none :mkdirp yes


* Early initialization
:PROPERTIES:
:header-args:emacs-lisp: :tangle ../early-init.el
:END:
** Performance settings

From Lambda Emacs. All credit to Colin McLear.

#+begin_src emacs-lisp

;;; early-init.el --- summary -*- lexical-binding: t; no-byte-compile: t; mode: emacs-lisp; coding:utf-8; fill-column: 80 -*-

;; This file is not part of GNU Emacs

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; This is the early-init file. Only for use with emacs 27 or higher. See
;; https://www.reddit.com/r/emacs/comments/7yns85/emacs_adds_support_for_a_second_read_earlier_init/
;; and https://lists.gnu.org/archive/html/emacs-devel/2017-10/msg00372.html for
;; more information.

;;;; Speed up startup
;; Help speed up emacs initialization See
;; https://blog.d46.us/advanced-emacs-startup/ and
;; http://tvraman.github.io/emacspeak/blog/emacs-start-speed-up.html and
;; https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/
;; This will be set back to normal at the end of the init file

(defvar lem-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

;;;; Garbage collection

;; Defer garbage collection further back in the startup process. We'll lower
;; this to a more reasonable number at the end of the init process (i.e. at end of
;; init.el)

(setq gc-cons-threshold most-positive-fixnum)

;; Adjust garbage collection thresholds during startup, and thereafter
;; See http://akrl.sdf.org https://gitlab.com/koral/gcmh

(defmacro k-time (&rest body)
  "Measure and return the time it takes evaluating BODY."
  `(let ((time (current-time)))
     ,@body
     (float-time (time-since time))))

;; When idle for 15sec run the GC no matter what.
(defvar k-gc-timer
  (run-with-idle-timer 15 t
                       (lambda ()
                         (let ((inhibit-message t))
                           (message "Garbage Collector has run for %.06fsec"
                                    (k-time (garbage-collect)))))))

;;;; Native Comp

;; See https://github.com/jimeh/build-emacs-for-macos#native-comp
;; https://akrl.sdf.org/gccemacs.html#org335c0de
;; https://github.com/emacscollective/no-littering/wiki/Setting-gccemacs'-eln-cache
;; https://debbugs.gnu.org/cgi/bugreport.cgi?bug=53891
;; https://emacs.stackexchange.com/a/70478/11934

;; See if native-comp is available
(cond ((not (and (fboundp 'native-comp-available-p)
                 (native-comp-available-p)))
       (message "Native complation is *not* available"))
      ;; Put eln-cache dir in cache directory
      ;; NOTE the method for setting the eln-cache dir depends on the emacs version
      ((version< emacs-version "29")
       (setcar native-comp-eln-load-path
               (expand-file-name (convert-standard-filename "var/cache/eln-cache/") user-emacs-directory)))
      (t
       (startup-redirect-eln-cache (convert-standard-filename (expand-file-name "var/cache/eln-cache/" user-emacs-directory)))))

;; Silence nativecomp warnings popping up
(customize-set-variable 'native-comp-async-report-warnings-errors nil)

;; Native-comp settings
(customize-set-variable 'native-comp-speed 2)
(customize-set-variable 'native-comp-deferred-compilation t)

;;;; Set C Directory
;; NOTE this assumes that the C source files are included with emacs.
;; This depends on the build process used.
;; For one example see https://github.com/mclear-tools/build-emacs-macos
(setq find-function-C-source-directory "/Applications/Emacs.app/Contents/Resources/src")

;;;; Prefer Newer files
;; Prefer newer versions of files
(setq load-prefer-newer t)

;;;; Byte Compile Warnings
;; Disable certain byte compiler warnings to cut down on the noise. This is a
;; personal choice and can be removed if you would like to see any and all byte
;; compiler warnings.
(customize-set-variable 'byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local obsolete))
;;;; Check Errors
;; Don't produce backtraces when errors occur.
;; This can be set to `t' interactively when debugging.
(customize-set-variable 'debug-on-error nil)

;;;; When-let errors
;; https://github.com/alphapapa/frame-purpose.el/issues/3
(eval-and-compile
  (when (version< emacs-version "26")
    (with-no-warnings
      (defalias 'when-let* #'when-let)
      (function-put #'when-let* 'lisp-indent-function 1)
      (defalias 'if-let* #'if-let)
      (function-put #'if-let* 'lisp-indent-function 2))))

;;;; Variable Binding Depth
;; This variable controls the number of lisp bindings that can exists at a time.
;; We should make it fairly large for modern machines.
;; https://www.reddit.com/r/emacs/comments/9jp9zt/anyone_know_what_variable_binding_depth_exceeds/
(customize-set-variable 'max-specpdl-size 13000)

#+end_src

** System variables

#+begin_src emacs-lisp

;;;; System variables

(setq user-emacs-directory (expand-file-name user-emacs-directory))

#+end_src

** Customize interface

#+begin_src emacs-lisp

;;;; Customize interface

(setq custom-file (concat user-emacs-directory "persistent/custom.el"))
(load-file custom-file)

#+end_src

** Mirage core

#+begin_src emacs-lisp

;;;; Mirage core

;; Load path
(add-to-list 'load-path (concat user-emacs-directory "mirage/core/"))

;; Load all core components
(defvar mirage-core-components '("package-manager"
                                 "config-management"
                                 "base-config"))
(mapc (lambda (component) (require (intern (concat "mirage-core-" component)) (concat "mirage-" component)))
      mirage-core-components)

;;; early-init.el ends here

#+end_src


* Mirage Core
** Package manager
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/mirage-package-manager.el
:END:

#+begin_src emacs-lisp

;;;; straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;;;; use-package
(straight-use-package 'use-package)

;; fall back to straight.el
(setq straight-use-package-by-default t)

#+end_src

** Config management
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/mirage-config-management.el
:END:
*** Component loading

#+begin_src emacs-lisp

(defun mirage-load-component (type component)
  "Load a mirage COMPONENT of the given TYPE"
  (let ((component-name (symbol-name component)))
       (condition-case err
           (require (intern (concat "mirage-" type "-" component-name)) (concat user-emacs-directory "mirage/" type "s" "/mirage-" component-name ".el"))
         (error (progn (message "ERROR: mirage-%s %s load failed" component-name type)
		       (if debug-on-error
		           (debug err)))))))

;; mirage modules
(defun mirage-module (module)
  "Load a mirage MODULE by name"
  (mirage-load-component "module" module))

;; mirage layers
(defun mirage-layer (layer)
  "Load a mirage LAYER by name"
  (mirage-load-component "layer" layer))

;; mirage extensions
(defun mirage-extend (extension)
  "Load a mirage EXTENSION by name"
  (mirage-load-component "extension" extension))

#+end_src

*** Async tangling

#+begin_src emacs-lisp

;;;; Load async package
(straight-use-package 'async)
(require 'async)

;;;; Tangling machinery
(defun mirage/tangle (org-file &optional quiet)
  "Asynchronously tangle an org file."
  ;; Record initial time, name of current buffer and set async quiet switch
  (let ((init-tangle-start-time (current-time))
	(file (buffer-file-name))
	(async-quiet-switch "-q"))
    ;;; Async start
    (async-start
     ;;; Tangling function
     `(lambda ()
        ;; Delete all pre-existing Mirage components
        (dolist (comp-dir (mapcar (lambda (dir) (concat ,user-emacs-directory "mirage/" dir)) '("core" "layers" "modules" "extensions")))
          (dolist (file (directory-files comp-dir t directory-files-no-dot-files-regexp))
            (delete-file file)))
        ;; Require org-mode
	(require 'org)
        ;; Create a new org-mode tangling hook
	(add-hook 'org-babel-post-tangle-hook
		  (lambda ()
                    ;; Obtain component and component type from the name of the source file being tangled to
                    (if (string-match "\\(^.*/mirage/\\)\\(.*\\)\\(/mirage-\\)\\(.*\\)\\(.el\\)" (buffer-file-name))
		        (let ((component (match-string 4 (buffer-file-name)))
			      (comp-type (match-string 2 (buffer-file-name))))
		          (end-of-buffer)
		          (insert (concat
			           "\n"
			           "(provide 'mirage-" (if (string-match-p "^.*s" comp-type)
                                                           (substring comp-type 0 -1)
                                                         comp-type)
                                   "-" component ")\n"
			           ";;; mirage-" component ".el ends here"))
		          (save-buffer)))))
        ;; Tangle current file
	(org-babel-tangle-file ,org-file))
     ;;; Report success and tangling time (or failure)
     (unless quiet
       `(lambda (result)
	  (if result
	      (message "|mirage| Mirage components successfully tangled (%.2fs)."
		       (float-time (time-subtract (current-time) ',init-tangle-start-time)))
	    (message "|mirage| Mirage component tangling failed.")))))))

(defun mirage/tangle-auto ()
  "Automatically tangle Org Mode files in the Emacs config directory"
  (let* ((file   (expand-file-name buffer-file-name))
	 (config (string-match (concat user-emacs-directory "config.org$") file))
	 (mirage (string-match (concat user-emacs-directory "mirage/mirage.org$") buffer-file-name))
	 (org-confirm-babel-evaluate nil))
    (if mirage (mirage/tangle file))
    (if config (org-babel-tangle))))

(add-hook 'after-save-hook #'mirage/tangle-auto)

#+end_src

*** No littering

#+begin_src emacs-lisp

;;;; no-littering
(straight-use-package 'no-littering)
(require 'no-littering)

#+end_src

*** Patching

#+begin_src emacs-lisp

;;;; el-patch
(straight-use-package 'el-patch)
(require 'el-patch)

#+end_src

*** Debugging

#+begin_src emacs-lisp

(setq debug-on-error nil)

(global-set-key (kbd "C-c SPC") #'whitespace-mode)

#+end_src

** Base configuration
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/mirage-base-config.el
:END:

#+begin_src emacs-lisp

;; utilities
(mirage-extend 'get)
(mirage-extend 'queries)
(mirage-extend 'execution)
(mirage-extend 'operators)

;; UI
(mirage-layer 'ui)
(mirage-layer 'themes)
(mirage-layer 'dashboard)

;; input
(mirage-layer 'input)

;; org-mode
(mirage-layer 'org)
(mirage-layer 'org-ui)
(mirage-layer 'org-inline)
(mirage-layer 'org-typesetting)
(mirage-layer 'org-export)

;; org applications
(mirage-layer 'org-notebooks)
(mirage-layer 'org-zettelkasten)
(mirage-layer 'org-agenda)

;; PDFs
(mirage-layer 'pdf)

;; magit
(mirage-layer 'version-control)

#+end_src


* Layers

Content of a layer:
- Settings
- Built-in modes
- Modules
- Extensions
- Bindings

** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-ui.el
:END:
*** Text
**** Typefaces

#+begin_src emacs-lisp

;; icons
(mirage-module 'all-the-icons)

#+end_src

**** Highlights

#+begin_src emacs-lisp

;; highlights
(mirage-module 'rainbow-mode)

#+end_src

*** Buffer

#+begin_src emacs-lisp

;; centering
(mirage-module 'olivetti)

;; line numbers
(global-set-key (kbd "C-c l") #'display-line-numbers-mode)

#+end_src

*** Frame

#+begin_src emacs-lisp

;; size
(add-to-list 'default-frame-alist '(height . 50))
(add-to-list 'default-frame-alist '(width  . 70))

;; tabs
(tab-bar-mode -1)
;; scroll bar
(scroll-bar-mode -1)
;; toolbar
(tool-bar-mode -1)
;; tooltips
(tooltip-mode -1)
;; menu bar
(menu-bar-mode -1)

;; title
(setq-default frame-title-format '("%b"))

#+end_src

*** Window

#+begin_src emacs-lisp

;; fringes
(set-fringe-mode nil)

;; balance
(global-set-key (kbd "C-x -") #'balance-windows)

;; split threshold
(setq split-width-threshold 70)

#+end_src

*** Warnings

#+begin_src emacs-lisp

;; visible bell
(setq visible-bell t)

#+end_src

*** Mode line

#+begin_src emacs-lisp

;; time
(display-time-mode t)

;; column numbers
(column-number-mode)

;; mode display
(mirage-module 'delight)

#+end_src

*** Extensions

#+begin_src emacs-lisp

;; extensions
(mirage-extend 'ui)

#+end_src

** Themes
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-themes.el
:END:

Mirage themes layer. It requires three variables to be defined: the light and dark themes (~light~ and ~dark~ respectively).

#+begin_src emacs-lisp

(defcustom light-theme 'nil
  "Light theme")
(defcustom dark-theme  'nil
  "Dark theme")

;; creation
(mirage-module 'autothemer)

;; theme switching
(mirage-extend 'theme-switch)

;; scheduling
(mirage-module 'circadian)

#+end_src

** Mode line
*** Doom
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-modeline-doom.el
:END:

#+begin_src emacs-lisp

;; modules
(mirage-module 'doom-modeline)

;; extensions
(mirage-extend 'theme-modeline)

#+end_src

*** Nano
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-modeline-nano.el
:END:

#+begin_src emacs-lisp

;; modules
(mirage-module 'nano-modeline)

;; extensions
(mirage-extend 'theme-modeline)

#+end_src

*** Moody
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-modeline-moody.el
:END:

#+begin_src emacs-lisp

(mirage-module 'moody)

;; modeline height
(setq moody-mode-line-height 22)

;; adjust modeline elements to enable moody
(let ((line (face-attribute 'mode-line :underline)))
  (set-face-attribute 'mode-line          nil :overline   line)
  (set-face-attribute 'mode-line-inactive nil :overline   line)
  (set-face-attribute 'mode-line-inactive nil :underline  line)
  (set-face-attribute 'mode-line          nil :box        nil)
  (set-face-attribute 'mode-line-inactive nil :box        nil))

;; extensions
(mirage-extend 'theme-modeline)

#+end_src

*** Spaceline
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-modeline-spaceline.el
:END:

#+begin_src emacs-lisp

;; modules
(mirage-module 'spaceline)

#+end_src

** Dashboard
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-dashboard.el
:END:

#+begin_src emacs-lisp

;; requirements
(mirage-module 'projectile)
(mirage-module 'all-the-icons)
(mirage-module 'page-break-lines)

;; dashboard
(mirage-module 'emacs-dashboard)

;; init info
(setq dashboard-set-init-info t)

;; center content
(setq dashboard-center-content t)

;; dashboard items
(setq dashboard-items '((recents  . 5)
                        (projects . 5)
                        (bookmarks . 5)
                        (registers . 5)
                        (agenda . 5)))

;; banner
(setq dashboard-startup-banner (concat user-emacs-directory "mirage/art/gwd-light.png"))
(add-hook 'mirage/enable-or-load-theme-hook (lambda () (let ((active-theme (car custom-enabled-themes)))
                                                         (setq dashboard-startup-banner (concat user-emacs-directory "mirage/art/"
                                                                                                (if (eq active-theme light-theme)
                                                                                                    "gwd-light.png"
                                                                                                  "gwd-dark.png")))
                                                         (if (string-equal (buffer-name (current-buffer)) "*dashboard*")
                                                             (revert-buffer)))))
(setq dashboard-image-banner-max-width 300)

;; title
(setq dashboard-banner-logo-title "⚓ Welcome on Board! ⚓")

;; footer
(setq dashboard-set-footer t)
(setq dashboard-footer-icon (all-the-icons-fileicon "emacs"
                                                    :height 1
                                                    :v-adjust -0.15
                                                    :face 'font-lock-constant-face))

#+end_src


** Input
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-input.el
:END:

#+begin_src emacs-lisp

;; confirmation
(advice-add 'yes-or-no-p :override #'y-or-n-p)
;; advanced commands
(put 'narrow-to-region 'disabled nil)

;; modules
(mirage-module 'evil)
(mirage-module 'god-mode)

;; extensions
(mirage-extend 'rsi)

#+end_src

** Completion
*** ivy
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-completion-ivy.el
:END:

#+begin_src emacs-lisp

(mirage-module 'ivy)

#+end_src

*** vertico
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-completion-vertico.el
:END:

#+begin_src emacs-lisp

(mirage-module 'vertico)
(mirage-module 'orderless)

;; icons
(mirage-module 'all-the-icons)
(mirage-module 'all-the-icons-completion)

#+end_src

** Navigation
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-navigation.el
:END:

#+begin_src emacs-lisp

;; scrolling
(pixel-scroll-precision-mode)
(setq auto-window-vscroll nil)
(setq mouse-wheel-progressive-speed nil)

;; horizontal scrolling
(put 'scroll-left  'disabled nil)
(put 'scroll-right 'disabled nil)
;; mouse wheel
(global-set-key (kbd "S-<wheel-up>")    (lambda () (interactive) (scroll-right 2)))
(global-set-key (kbd "S-<wheel-down>")  (lambda () (interactive) (scroll-left  2)))
;; mouse side wheel
(global-set-key (kbd "S-<wheel-left>")  (lambda () (interactive) (scroll-right 4)))
(global-set-key (kbd "S-<wheel-right>") (lambda () (interactive) (scroll-left  4)))

;; buffers
(global-set-key (kbd "M-<delete>") #'bury-buffer)

;; windows
(winner-mode)

;; modules
(mirage-module 'ace-window)

;; extensions
(mirage-extend 'navigation)

;; bindings
(global-set-key (kbd "C-S-n") #'make-frame-command)

#+end_src


** Search
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-search.el
:END:

#+begin_src emacs-lisp

;; modules
(mirage-module 'swiper)
(mirage-module 'rg)

;; extensions
(mirage-extend 'search)

#+end_src

** Editing
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-editing.el
:END:

#+begin_src emacs-lisp

;; settings
(setq-default indent-tabs-mode nil)

;; built-ins
(global-so-long-mode 1)

;; modules
(mirage-module 'vundo)
(mirage-module 'multiple-cursors)

;; extensions
(mirage-extend 'editing)

#+end_src

** Workflow
*** Session
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-session.el
:END:

#+begin_src emacs-lisp

;; built-ins
(desktop-save-mode 1)

;; modules
(mirage-module 'workgroups)
(mirage-module 'super-save)

;; extensions
(mirage-extend 'session)
(mirage-extend 'external-programs)

#+end_src 

*** TODO Project interaction
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-project-interaction.el
:END:

#+begin_src emacs-lisp

;; modules
(mirage-module 'projectile)
(mirage-module 'treemacs)

#+end_src

** Version control
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-version-control.el
:END:

#+begin_src emacs-lisp

(mirage-module 'magit)
(mirage-module 'forge)

#+end_src

** File management
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-file-management.el
:END:

~backup-directory-alist~, which determines where backups are saved, is set by ~no-littering~.

#+begin_src emacs-lisp

;; buffer backups
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 2)
(setq kept-old-versions 2)

;; file manager
(mirage-module 'dirvish)

;; extensions
(mirage-extend 'file-management)

#+end_src


** TODO IDE
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-ide.el
:END:

#+begin_src emacs-lisp

;; remove duplicates in shell history
(setq comint-input-ignoredups t)
;; indentation
(setq-default c-basic-offset 4)
;; electric pairs
(setq electric-pair-pairs
      '((?\( . ?\))
        (?\[ . ?\])
        (?\{ . ?\})
        (?\" . ?\")))
(electric-pair-mode)

;; outline
(mirage-module 'hideshow)
;; editing
(mirage-module 'puni)
(mirage-module 'embrace)
;; completion
(mirage-module 'company)
;; syntax checking
(mirage-module 'flycheck)
;; language server protocol
(mirage-module 'lsp-mode)

;; lisp
(mirage-module 'rainbow-delimiters)
;; python
(mirage-module 'elpy)
;; rust
(mirage-module 'rustic)

#+end_src

** PDF
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-pdf.el
:END:

#+begin_src emacs-lisp

;; settings
(setq doc-view-resolution 250)

;; requirements
(mirage-module 'tablist)

;; modules
(mirage-module 'pdf-tools)
(mirage-module 'pdf-view-restore)

;; extensions
(mirage-extend 'pdf)

#+end_src

** TODO LaTeX
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-latex.el
:END:

#+begin_src emacs-lisp

(add-hook 'latex-mode-hook (lambda () (visual-line-mode nil)))

#+end_src

** Org Mode
*** Configuration
**** Base
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org.el
:END:

#+begin_src emacs-lisp

;; settings
(setq-default org-use-property-inheritance t)

;; bindings
(global-set-key (kbd "C-x c") #'org-capture)

;; dependencies
(mirage-layer  'editing)

;; org
(mirage-module 'org)

;; editing
(mirage-module 'org-paragraph)
(mirage-module 'org-download)

;; templates
(mirage-module 'org-tempo)
(mirage-module 'org-capture)

;; agenda
(mirage-module 'org-agenda)
(mirage-module 'org-contacts)
(mirage-module 'org-calendar)
(mirage-extend 'org-agenda)

;; extensions
(mirage-extend 'org-get)
(mirage-extend 'org-queries)
(mirage-extend 'org-editing)
(mirage-extend 'org-ui)
(mirage-extend 'org-outline)
(mirage-extend 'org-navigation)

#+end_src

**** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-ui.el
:END:

#+begin_src emacs-lisp

;; org-indent-mode
(setq org-startup-indented nil)
;; tag indentation
(setq org-tags-column 0)
;; list indentation
(setq-default org-list-indent-offset 1)
;; startup with inline images
(setq org-startup-with-inline-images t)
;; do not force inline images to their actual width
(setq org-image-actual-width nil)
;; do not consider empty lines content
(setq org-cycle-separator-lines 2)

;; line wrapping
(add-hook 'org-mode-hook (lambda () (progn (visual-line-mode 1) (setq line-move-visual t))))

;; design
(mirage-module 'org-modern)
(setq org-modern-table        nil)
(setq org-modern-block-fringe nil)

#+end_src

**** Inline previews
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-inline.el
:END:
***** Org Markup

#+begin_src emacs-lisp

;; markup
(mirage-module 'org-appear)

#+end_src

***** LaTeX equations

#+begin_src emacs-lisp

;; inline LaTeX previews
(mirage-module 'org-fragtog)

#+end_src

****** TODO Options

- mail bug in

Importantly, ~modus-vivendi~ will not behave correctly with
the default ~org-format-latex-options~, with LaTeX previews
displaying as white boxes. [[https://debbugs.gnu.org/db/52/52277.html][This has been previously reported]].

~org-format-latex-options~ has ~:foreground~ and ~:background~
attributes. These may be assigned to

- a color,
- ~default~, instructing Org Mode to determine ~:foreground~ or
  ~:background~ from the foreground or background color of the
  default face, or
- ~auto~, doing the same for the text face.

By default, the ~:foreground~ and ~:background~ in ~org-format-latex-options~
are set to ~default~. With default settings, changing the color
of the ~default~ font has the following effects on the LaTeX preview SVGs:

- modus-operandi
   - ~default :foreground~: text color
   - ~default :background~: no effect
- modus-vivendi
   - ~default :foreground~: background color
   - ~default :background~: no effect

By eliminating the ~:background~ attribute from ~org-format-latex-options~
the issue is resolved.

1. ~modus-operandi~ does not suffer from this issue nor do various
   other themes. This makes me believe the issue lies with
   ~modus-vivendi~ itself.
2. However, the ~:background~ attribute in ~org-format-latex-options~
   seems to have no effect, a potential bug in Org Mode

#+begin_src emacs-lisp

(setq org-format-latex-options
        (list :foreground 'default
              :scale       1.000))

#+end_src

****** Header

#+begin_src emacs-lisp

(setq mirage/org-latex-preview-class-args "fleqn")
(setq mirage/org-latex-preview-width      "18cm")

(setq org-format-latex-header
      (string-join `("\\documentclass[" ,mirage/org-latex-preview-class-args "]{article}"
		         "\\usepackage[usenames]{color}"
			
			 "\\usepackage{bm}"
			
			 "\\pagestyle{empty}"
			 "\\setlength{\\textwidth}{" ,mirage/org-latex-preview-width "}"
			 "\\addtolength{\\textwidth}{-3cm}"
			 "\\setlength{\\oddsidemargin}{1.5cm}"
			 "\\addtolength{\\oddsidemargin}{-2.54cm}"
			 "\\setlength{\\evensidemargin}{\\oddsidemargin}"
			 "\\setlength{\\textheight}{\\paperheight}"
			 "\\addtolength{\\textheight}{-\\headheight}"
			 "\\addtolength{\\textheight}{-\\headsep}"
			 "\\addtolength{\\textheight}{-\\footskip}"
			 "\\addtolength{\\textheight}{-3cm}"
			 "\\setlength{\\topmargin}{1.5cm}"
			 "\\addtolength{\\topmargin}{-2.54cm}")
		   "\n"))

#+end_src

****** Equation preview format

#+begin_src emacs-lisp

;; SVG LaTeX equation preview
(setq org-latex-create-formula-image-program 'dvisvgm)

#+end_src

****** Equation preview directory

#+begin_src emacs-lisp

;; theme-specific LaTeX preview directory
(defun mirage/latex-preview-directory ()
  "Set `org-preview-latex-image-directory' to the SVG
LaTeX preview directory of the current theme"
  (setq org-preview-latex-image-directory
   (concat "/tmp/ltximg/" (mirage/get-active-theme) "/")))

#+end_src

****** Equation preview reload hook

#+begin_src emacs-lisp

(defun mirage/latex-preview-reload ()
  "Reload all LaTeX previews in buffer,
ensuring the LaTeX preview directory
matches the current theme."
  (if (string-equal major-mode "org-mode")
      (progn (org-latex-preview '(64))
	     (mirage/latex-preview-directory)
	     (org-latex-preview '(16)))))

(add-hook 'org-mode-hook #'mirage/latex-preview-reload)

#+end_src

**** Typesetting of Org Mode files
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-typesetting.el
:END:
***** Text
****** Typefaces
******* Body

#+begin_src emacs-lisp

(defun mirage/org-typefaces-body ()
  (with-eval-after-load 'org-faces

    ;; Code
    (set-face-attribute 'org-block                 nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code                  nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim              nil :inherit '(shadow fixed-pitch))

    ;; Tables
    (set-face-attribute 'org-table                 nil :inherit '(shadow fixed-pitch))

    ;; Lists
    (set-face-attribute 'org-checkbox              nil :inherit 'fixed-pitch)

    ;; Meta
    (set-face-attribute 'org-meta-line             nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-document-info         nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-document-info-keyword nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-special-keyword       nil :inherit 'fixed-pitch)))

(add-hook 'org-mode-hook #'mirage/org-typefaces-body)

#+end_src

******* Heading

#+begin_src emacs-lisp

;; use levels 1 through 16
(setq org-n-level-faces 8)

;; do not cycle header style after 8th level
(setq org-cycle-level-faces t)

;; hide leading stars
(setq org-hide-leading-starts t)

;; font sizes
(defun mirage/org-heading-typefaces () 
  (with-eval-after-load 'org-faces
    (dolist (face '((org-level-1  . 1.175)
                    (org-level-2  . 1.175)
                    (org-level-3  . 1.175)
                    (org-level-4  . 1.175)
                    (org-level-5  . 1.175)
                    (org-level-6  . 1.175)
                    (org-level-7  . 1.175)
                    (org-level-8  . 1.175)))
         (set-face-attribute (car face) nil :font typeface-heading :weight 'bold :height (cdr face)))))

;; org-mode hook
(add-hook 'org-mode-hook #'mirage/org-heading-typefaces)

;; theme hooks
(add-hook 'mirage/enable-or-load-theme-hook #'mirage/org-typefaces-body)
(add-hook 'mirage/enable-or-load-theme-hook #'mirage/org-heading-typefaces)

#+end_src

****** Pretty entities

#+begin_src emacs-lisp

;; symbols, super- and subscripts
(setq org-pretty-entities nil)

#+end_src

***** Icons
****** Ellipses

Candidates:
- triangles
  ▼
  ▾
  ▿
- rhomboids
  ⬙
  ⟡
  ⬥
  ♦
  ♢
- non-compliant
  ⧨
  
-----

#+begin_src emacs-lisp

;; Change ellipsis ("...") to remove clutter
(setq org-ellipsis " ♢")

#+end_src

**** Export
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-export.el
:END:

#+begin_src emacs-lisp

;; presentations
(mirage-module 'org-reveal)

#+end_src

*** Applications
**** Agenda
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-agenda.el
:END:

#+begin_src emacs-lisp

;; settings
(setq org-agenda-skip-scheduled-if-done nil)
(setq org-agenda-skip-deadline-if-done nil)
(setq org-agenda-window-setup 'current-window)
(setq org-deadline-warning-days 14)

;; bindings
(define-key org-agenda-mode-map (kbd "<tab>") 'org-agenda-recenter)

;; modules
(mirage-module 'org-agenda)
(mirage-module 'org-super-agenda)
(mirage-module 'org-rainbow-tags)

;; base TODO keyword sequence
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "WAIT(w@/!)" "|" "DONE(d!)")))

;; base custom agenda views
(setq org-agenda-custom-commands
      '(("d" "Daily Dashboard"
	 ((agenda "" ((org-agenda-span 1)
                      (org-deadline-warning-days 4)))
	  (todo "TODO" ((org-agenda-overriding-header "Unscheduled Tasks")
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'scheduled 'deadline))))))
        ("w" "Weekly Dashboard"
	 ((agenda "" ((org-deadline-warning-days 14)))
	  (todo "TODO" ((org-agenda-overriding-header "Unscheduled Tasks")
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'scheduled 'deadline))))))
        ("b" "Birthdays"
         ((org-super-agenda-mode -1)
          (agenda "" ((org-agenda-ndays 7))))
         ((org-agenda-regexp-filter-preset '("Birthday"))))))

#+end_src

**** Notebooks
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-notebooks.el
:END:

#+begin_src emacs-lisp

(mirage-module 'org-babel)
(mirage-module 'ox-ipynb)
(mirage-extend 'org-babel)

#+end_src

**** Zettelkasten
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-zettelkasten.el
:END:

#+begin_src emacs-lisp

(mirage-module 'org-roam)
(mirage-module 'org-roam-ui)
(mirage-module 'org-roam-timestamps)

#+end_src

**** GTD
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/mirage-org-gtd.el
:END:
***** Agenda
****** Keywords

#+begin_src emacs-lisp

(add-to-list 'org-todo-keywords
             '(sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(r)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)") t)

#+end_src

****** Views

#+begin_src emacs-lisp

(add-to-list 'org-agenda-custom-commands
             '("s" "Workflow Status"
	       ((todo "WAIT"
		      ((org-agenda-overriding-header "Waiting on External")
		       (org-agenda-files org-agenda-files)))
	        (todo "REVIEW"
		      ((org-agenda-overriding-header "In Review")
		       (org-agenda-files org-agenda-files)))
	        (todo "PLAN"
		      ((org-agenda-overriding-header "In Planning")
		       (org-agenda-todo-list-sublevels nil)
		       (org-agenda-files org-agenda-files)))
	        (todo "BACKLOG"
		      ((org-agenda-overriding-header "Project Backlog")
		       (org-agenda-todo-list-sublevels nil)
		       (org-agenda-files org-agenda-files)))
	        (todo "READY"
		      ((org-agenda-overriding-header "Ready for Work")
		       (org-agenda-files org-agenda-files)))
	        (todo "ACTIVE"
		      ((org-agenda-overriding-header "Active Projects")
		       (org-agenda-files org-agenda-files)))
	        (todo "COMPLETED"
		      ((org-agenda-overriding-header "Completed Projects")
		       (org-agenda-files org-agenda-files)))
	        (todo "CANC"
		      ((org-agenda-overriding-header "Cancelled Projects")
		       (org-agenda-files org-agenda-files)))))
             t)

#+end_src

***** Pomodoro

#+begin_src emacs-lisp

(mirage-module 'org-pomodoro)

#+end_src


* Modules

Content of a module:
- Package installation
- Package setup

** UI
*** Buffer
**** olivetti
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-olivetti.el
:END:

#+begin_src emacs-lisp

;; centering
(straight-use-package 'olivetti)

(add-hook 'olivetti-mode-on-hook (lambda () (olivetti-set-width 0.9)))

;; normal modes
(dolist (mode '(org-mode-hook
		     shell-mode-hook
		     markdown-mode-hook
                latex-mode-hook))
  (add-hook mode 'olivetti-mode))

;; Programming modes
(add-hook 'prog-mode-hook #'olivetti-mode)

#+end_src

***** Patches

#+begin_src emacs-lisp

(require 'el-patch)

#+end_src

****** olivetti-set-width

#+begin_src emacs-lisp

(el-patch-feature olivetti)
(el-patch-defun olivetti-set-width (width)
  "Set text body width to WIDTH with relative margins.
WIDTH may be an integer specifying columns or a float specifying
a fraction of the window width."
  (interactive
   (list (if current-prefix-arg
             (prefix-numeric-value current-prefix-arg)
           (read-number "Set text body width (integer or float): "
                        olivetti-body-width))))
  (setq olivetti-body-width width)
  (olivetti-set-buffer-windows)
  (el-patch-remove (message "Text body width set to %s" olivetti-body-width)))

#+end_src

**** solaire-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-solaire-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'solaire-mode)
(require 'solaire-mode)

#+end_src

**** page-break-lines
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-page-break-lines.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'page-break-lines)
(require 'page-break-lines)

#+end_src

*** Mode line
**** delight
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-delight.el
:END:

#+begin_src emacs-lisp

;; Customize names displayed in mode line
(straight-use-package 'delight)
(require 'delight)

;; Remove default modes from mode line
(delight '((global-command-log-mode nil "")
	   (olivetti-mode           nil "")
	   (which-key-mode          nil "")
	   (visual-line-mode        nil "simple")
	   (buffer-face-mode        nil "simple")
	   (org-indent-mode         nil "org")
	   (eldoc-mode              nil "eldoc")
	   ;; Major modes
	   (emacs-lisp-mode "EL" :major)))

#+end_src

*** Typefaces
**** all-the-icons
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-all-the-icons.el
:END:

#+begin_src emacs-lisp

;; Symbol library
(straight-use-package 'all-the-icons)

#+end_src

Now that ~all-the-icons~ is installed, all the icon typefaces must be actually present in
the local machine:

#+begin_src emacs-lisp :tangle no

(all-the-icons-install-fonts)

#+end_src

*** Highlights
**** svg-tag-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-svg-tag-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'svg-tag-mode)
(require 'svg-tag-mode)

(defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
(defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
(defconst day-re "[A-Za-z]\\{3\\}")
(defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

(defun svg-progress-percent (value)
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ (string-to-number value) 100.0)
                                    nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag (concat value "%")
                           nil :stroke 0 :margin 0)) :ascent 'center))

(defun svg-progress-count (value)
  (let* ((seq (mapcar #'string-to-number (split-string value "/")))
         (count (float (car seq)))
         (total (float (cadr seq))))
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ count total) nil
                                    :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag value nil
                           :stroke 0 :margin 0)) :ascent 'center)))

(setq svg-tag-tags
      `(
        ;; Org tags
        (":\\([A-Za-z0-9]+\\)" . ((lambda (tag) (svg-tag-make tag))))
        (":\\([A-Za-z0-9]+[ \-]\\)" . ((lambda (tag) tag)))
        
        ;; Task priority
        ("\\[#[A-Z]\\]" . ( (lambda (tag)
                              (svg-tag-make tag :face 'org-priority 
                                            :beg 2 :end -1 :margin 0))))

        ;; Progress
        ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag) (svg-progress-percent (substring tag 1 -2)))))
        ("\\(\\[[0-9]+/[0-9]+\\]\\)"   . ((lambda (tag) (svg-progress-count (substring tag 1 -1)))))
        
        ;; TODO / DONE
        ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo :inverse t :margin 0))))
        ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))


        ;; Citation of the form [cite:@Knuth:1984]
        ("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
                                          (svg-tag-make tag
                                                        :inverse t
                                                        :beg 7 :end -1
                                                        :crop-right t))))
        ("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
                                                (svg-tag-make tag
                                                              :end -1
                                                              :crop-left t))))
        
        ;; Active date (with or without day name, with or without time)
        (,(format "\\(<%s>\\)" date-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :end -1 :margin 0))))
        (,(format "\\(<%s \\)%s>" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
        (,(format "<%s \\(%s>\\)" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))

        ;; Inactive date  (with or without day name, with or without time)
         (,(format "\\(\\[%s\\]\\)" date-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date))))
         (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face 'org-date))))
         (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face 'org-date))))))

#+end_src

**** rainbow-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-rainbow-mode.el
:END:

#+begin_src emacs-lisp

;; highlight HTML color strings in their own color
(straight-use-package 'rainbow-mode)

#+end_src

*** Completion
**** all-the-icons-completion
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-all-the-icons-completion.el
:END:

#+begin_src emacs-lisp

(require 'all-the-icons)

(straight-use-package '(all-the-icons-completion :type git :host github :repo "MintSoup/all-the-icons-completion"))

(all-the-icons-completion-mode)

#+end_src

*** Dashboard
**** emacs-dashboard
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-emacs-dashboard.el
:END:

#+begin_src emacs-lisp

;; requirements
(require 'projectile)
(require 'all-the-icons)
(require 'page-break-lines)

(straight-use-package 'dashboard)
(require 'dashboard)

(dashboard-setup-startup-hook)

;; options
(setq dashboard-center-content t)
(setq dashboard-set-file-icons t)

;; initial buffer choice
(if (and (not initial-buffer-choice)
         (string-equal (buffer-name (current-buffer)) "*scratch*"))
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))))

#+end_src

** Themes
*** Themes
**** Ef
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-ef-themes.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(ef-themes :type git :host nil :repo "https://git.sr.ht/~protesilaos/ef-themes"))
(require 'ef-themes)

#+end_src

**** Nano
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-nano-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'nano-theme)
(require 'nano-theme)

;; always use load-theme + enable-theme for the nano themes
(advice-add 'enable-theme :around (lambda (orig-fun THEME) (if (string-match "^nano-.*" (symbol-name THEME))
                                                               (progn (load-theme THEME t t)
                                                                      (funcall orig-fun THEME))
                                                             (funcall orig-fun THEME))))

#+end_src

**** Doom
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-doom-themes.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'doom-themes)
(require 'doom-themes)

#+end_src

**** Solarized
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-solarized-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'solarized-theme)
(require 'solarized-theme)

#+end_src

**** Standalone
***** Sweet
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-sweet-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'sweet-theme)
(require 'sweet-theme)

#+end_src

***** Graphite
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-graphite-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(graphite-theme :type git :host github :repo "codemicmaves/graphite-theme"))
(require 'graphite-light-theme)
(require 'graphite-dark-theme)

#+end_src

***** Chocolate
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-chocolate-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'chocolate-theme)
(require 'chocolate-theme)

#+end_src

***** Doom Zen Writer
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-doom-zen-writer-theme.el
:END:

#+begin_src emacs-lisp

(load-file (concat user-emacs-directory "elisp/themes/doom-zen-writer-theme.el"))

#+end_src

*** Creation
**** autothemer
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-autothemer.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'autothemer)
(require 'autothemer)

#+end_src

*** Scheduling
**** circadian
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-circadian.el
:END:

#+begin_src emacs-lisp

(setq calendar-latitude      52.00667)
(setq calendar-longitude     4.355561)
(setq calendar-loadtion-name "Delft")
(setq calendar-standard-time-zone-name "CEST")
(setq calendar-daylight-time-zone-name "CET")

(straight-use-package 'circadian)

(add-hook 'after-init-hook (lambda () (progn (setq circadian-themes `((:sunrise . ,light-theme)  
			                                              (:sunset  . ,dark-theme)))
                                             (circadian-setup))))

#+end_src

** Mode line
*** Nano
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-nano-modeline.el
:END:

#+begin_src emacs-lisp

;; nano-modeline
(straight-use-package 'nano-modeline)

;; mode line initialization hook
(add-hook 'after-init-hook #'nano-modeline-mode)

#+end_src

*** Doom
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-doom-modeline.el
:END:

#+begin_src emacs-lisp

;; doom-modeline
(straight-use-package 'doom-modeline)

;; bar
(setq-default doom-modeline-bar-width 0.01)

;; mode line initialization hook
(add-hook 'after-init-hook #'doom-modeline-mode)

#+end_src

*** Moody
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-moody.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'moody)

;; configuration
(setq x-underline-at-descent-line t)
(moody-replace-mode-line-buffer-identification)
(moody-replace-vc-mode)
(moody-replace-eldoc-minibuffer-message-function)

;; reload active theme
(let ((active-theme (car custom-enabled-themes)))
  (if active-theme (enable-theme active-theme)))

#+end_src

*** Spaceline
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-spaceline.el
:END:

#+begin_src emacs-lisp

;; spaceline
(straight-use-package 'spaceline)
(require 'spaceline-config)

;; mode line initialization hook
(add-hook 'after-init-hook #'spaceline-emacs-theme)

#+end_src


** Input
*** Editing
**** evil
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-evil.el
:END:

#+begin_src emacs-lisp

;; evil
(straight-use-package 'evil)
(require 'evil)

;; bindings
(global-set-key (kbd "C-<escape>") #'evil-mode)

#+end_src

***** bugs

#+begin_src emacs-lisp

;; eliminate blinking cursor in pdf-pdf-view
(add-hook 'pdf-view-mode-hook (lambda ()
                                (set (make-local-variable 
                                      'evil-emacs-state-cursor)
                                     (list nil))))

#+end_src

***** states
****** evil-god

#+begin_src emacs-lisp

;; evil god state
(straight-use-package 'evil-god-state)
(require 'evil-god-state)

(evil-define-key 'normal global-map (kbd ",") #'evil-execute-in-god-state)

(evil-define-key 'god    global-map (kbd "<escape>") #'evil-god-state-bail)

;; mode indicators
(setq evil-normal-state-tag   (propertize " COMMAND " 'face '((:background "dark khaki"     :foreground "black")))
      evil-emacs-state-tag    (propertize "  EMACS  " 'face '((:background "turquoise"      :foreground "black")))
      evil-insert-state-tag   (propertize " ------- " 'face '((:background "dark sea green" :foreground "black")))
      evil-replace-state-tag  (propertize " REPLACE " 'face '((:background "dark orange"    :foreground "black")))
      evil-motion-state-tag   (propertize "  MOTION " 'face '((:background "khaki"          :foreground "black")))
      evil-visual-state-tag   (propertize "  VISUAL " 'face '((:background "light salmon"   :foreground "black")))
      evil-operator-state-tag (propertize " OPERATE " 'face '((:background "sandy brown"    :foreground "black"))))

(setq evil-default-cursor (quote (t "#750000"))
      evil-visual-state-cursor '("green" hollow)
      evil-normal-state-cursor '("green" box)
      evil-insert-state-cursor '("pink" (bar . 2)))

#+end_src

****** evil-org

#+begin_src emacs-lisp

(with-eval-after-load 'org
  (straight-use-package 'evil-org)
  (require 'evil-org)
  (evil-org-set-key-theme '(navigation insert textobjects additional calendar))

  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)

  ;; hooks
  (add-hook 'org-mode-hook  (lambda () (if evil-mode (evil-org-mode))))
  (add-hook 'evil-mode-hook (lambda () (if (string-equal major-mode "org-mode") (evil-org-mode)))))

#+end_src

**** meow
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-meow.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'meow)
(require 'meow)

#+end_src

***** setup

#+begin_src emacs-lisp

(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . ignore)))

#+end_src

***** load

#+begin_src emacs-lisp

(meow-setup)
(meow-global-mode 1)

#+end_src

*** Commands
**** god-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-god-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'god-mode)
(require 'god-mode)

;; god
(global-set-key (kbd "<escape>") #'god-mode-all)

;; local
(define-key god-local-mode-map (kbd "i") #'god-local-mode)

;; bindings
(define-key god-local-mode-map (kbd ".") #'repeat)
(define-key god-local-mode-map (kbd "]") #'forward-paragraph)
(define-key god-local-mode-map (kbd "[") #'backward-paragraph)

#+end_src

** Guidance
*** counsel
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-counsel.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'counsel)
(require 'counsel)

(global-set-key (kbd "M-x") #'counsel-M-x)

#+end_src

*** helpful
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-helpful.el
:END:

#+begin_src emacs-lisp

;; replace description key bindings by their helpful equivalents
(straight-use-package 'helpful)

(setq counsel-describe-function-function  #'helpful-callable)
(setq counsel-describe-variable-function  #'helpful-variable)

(global-set-key [remap describe-function] #'helpful-function)
(global-set-key [remap describe-command]  #'helpful-command)
(global-set-key [remap describe-variable] #'helpful-variable)
(global-set-key [remap describe-key]      #'helpful-key)

#+end_src

*** which-key
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-which-key.el
:END:

#+begin_src emacs-lisp

;; command suggestions
(straight-use-package 'which-key)
(require 'which-key)

(setq which-key-idle-delay 1.0)

(which-key-mode)

#+end_src

*** command-log-mode                                                  :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-command-log-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'command-log-mode)
(require 'command-log-mode)

(global-command-log-mode)

#+end_src

** Completion
*** ivy
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-ivy.el
:END:

#+begin_src emacs-lisp

;; ivy
(straight-use-package 'ivy)
(require 'ivy)

(ivy-mode 1)

;; minibuffer bindings
(let ((map ivy-minibuffer-map))
  (cl-loop for binding in '(("<tab>"       . ivy-alt-done)
			    ("<up>"        . ivy-previous-line-or-history)
			    ("C-l"         . ivy-alt-done)
			    ("C-j"         . ivy-next-line)
			    ("C-k"         . ivy-previous-line)
			    ("<backspace>" . ivy-backward-delete-char))
            do (define-key map (kbd (car binding)) (cdr binding))))

;; switch-buffer bindings
(let ((map ivy-switch-buffer-map))
  (cl-loop for binding in '(("C-k"   . ivy-previous-line)
 			        ("C-l"   . ivy-done)
			        ("C-d"   . ivy-switch-buffer-kill))
            do (define-key map (kbd (car binding)) (cdr binding))))

;; reverse-i-search bindings
(let ((map ivy-reverse-i-search-map))
  (cl-loop for binding in '(("C-k"   . ivy-previous-line)
			        ("C-d"   . ivy-reverse-i-search-kill))
            do (define-key map (kbd (car binding)) (cdr binding))))

#+end_src

*** ivy-rich                                                          :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-ivy-rich.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'ivy-rich)
(require 'ivy-rich)

(ivy-rich-mode 1)

#+end_src

*** vertico
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-vertico.el
:END:

#+begin_src emacs-lisp

(require 'savehist)
(savehist-mode)

(straight-use-package 'vertico)
(vertico-mode)

(defun crm-indicator (args)
  (cons (format "[CRM%s] %s"
                (replace-regexp-in-string
                 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                 crm-separator)
                (car args))
        (cdr args)))
(advice-add 'completing-read-multiple :filter-args #'crm-indicator)

(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

(setq enable-recursive-minibuffers t)

#+end_src

*** orderless
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-orderless.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'orderless)

(setq completion-styles '(orderless basic))
(setq completion-category-defaults nil)
(setq completion-category-overrides '((file (styles partial-completion))))

#+end_src

** Navigation
*** ace-window
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-ace-window.el
:END:

#+begin_src emacs-lisp

;; ace-window
(straight-use-package 'ace-window)
(require 'ace-window)

(global-set-key (kbd "C-x o") #'ace-window)

#+end_src


** Search
*** swiper
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-swiper.el
:END:

#+begin_src emacs-lisp

;; Swiper
(straight-use-package 'swiper)
(require 'swiper)

#+end_src

**** mc

#+begin_src emacs-lisp

(defun mirage/swiper-multiple-cursors ()
  (interactive)
  (swiper-mc)
  (minibuffer-keyboard-quit))

;; M-RET: multiple-cursors-mode
(define-key swiper-map (kbd "M-<return>") #'mirage/swiper-multiple-cursors)

#+end_src

**** isearch

#+begin_src emacs-lisp

(defun mirage/swiper-isearch (orig-fun &rest args)
  "`swiper-isearch' the selected region. If none are, `swiper-isearch'."
  (if (region-active-p)
      (let ((beg (region-beginning))
	    (end (region-end)))
	(deactivate-mark)
	(apply orig-fun (list (buffer-substring-no-properties beg end))))
    (apply orig-fun args)))

(advice-add 'swiper-isearch :around #'mirage/swiper-isearch)

(define-key global-map (kbd "C-s") #'swiper-isearch)

#+end_src

*** ripgrep
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-rg.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'rg)
(require 'rg)

#+end_src

** Editing
*** Undo
**** TODO vundo
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-vundo.el
:END:

- undo-fu
- Back
   - Record character number in current line relative to the end of the line
   - If impossible to go to previous position, to recorded character number of previous line
   - Org Mode
      - restore visibility before undone command
      - if previous command created heading
         - undo heading creation and restore visibility

#+begin_src emacs-lisp

;; vundo
(straight-use-package 'vundo)

(global-set-key (kbd "C-v") #'vundo)

#+end_src

**** undo-tree                                                        :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-undo-tree.el
:END:

#+begin_src emacs-lisp

;; undo-tree
(use-package undo-tree
  :bind (("M-/" . undo-tree-visualize)
         :map undo-tree-visualizer-mode-map
         ("RET" . undo-tree-visualizer-quit)
         ("ESC" . undo-tree-visualizer-quit))
  :config
  (global-undo-tree-mode))

#+end_src

***** Visualize in side buffer

#+begin_src emacs-lisp

;; visualize in side buffer
(defun mirage/undo-tree-split-side-by-side (orig-fun &rest args)
  "Split undo-tree side-by-side"
  (let ((split-height-threshold nil)
        (split-width-threshold 0))
    (apply orig-fun args)))

(advice-add 'undo-tree-visualize :around #'mirage/undo-tree-split-side-by-side)

#+end_src

*** Multiline
**** multiple-cursors
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-multiple-cursors.el
:END:

#+begin_src emacs-lisp

;; Multiple cursors
(straight-use-package 'multiple-cursors)
(require 'multiple-cursors)

;; mc-lists
(setq mc/list-file (concat user-emacs-directory "persistent/mc-lists.el"))

;; Create cursors
(global-set-key (kbd "C-.")         #'mc/mark-next-like-this)
(global-set-key (kbd "C-;")         #'mc/mark-previous-like-this)
(global-set-key (kbd "C-<mouse-1>") #'mc/add-cursor-on-click)
(global-unset-key [C-down-mouse-1]) ; necessary

;; Return as usual
(define-key mc/keymap (kbd "<return>")       #'electric-newline-and-maybe-indent)

;; Exit multiple-cursors-mode
(define-key mc/keymap (kbd "<escape>")       #'multiple-cursors-mode)
(define-key mc/keymap (kbd "<mouse-1>")      #'multiple-cursors-mode)
(define-key mc/keymap (kbd "<down-mouse-1>")   nil) ; necessary

#+end_src

** Workflow
*** Export
**** htmlize
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-htmlize.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'htmlize)

#+end_src

*** Session
**** workgroups
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-workgroups.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'workgroups)
(require 'workgroups)

(setq wg-prefix-key (kbd "C-c w"))

;; save commands
(define-key wg-map (kbd "s")   #'wg-save)
(define-key wg-map (kbd "C-s") #'wg-update-all-workgroups-and-save)

;; suppress animation
(setq wg-morph-on nil)

(global-set-key (kbd "C-c w") #'workgroups-mode)

#+end_src

*** Auto-save
**** super-save
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-super-save.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'super-save)

(super-save-mode +1)

#+end_src

*** Project interaction
**** projectile
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-projectile.el
:END:

#+begin_src emacs-lisp

;; projectile
(straight-use-package 'projectile)
(require 'projectile)

(projectile-mode)

;; command map prefix
(define-key projectile-mode-map (kbd "M-p") 'projectile-command-map)

#+end_src

**** treemacs
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-treemacs.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'treemacs)
(require 'treemacs)

#+end_src

***** Filter

#+begin_src emacs-lisp

(defvar mirage/treemacs-ignored '(".*__pycache__.*")
  "Files and directories ignored by treemacs")

(defun mirage/treemacs-ignore-filter (file _)
  (cl-loop for ignored in mirage/treemacs-ignored
	   if (string-match ignored file)
	      return t
	   finally return nil))
(push #'mirage/treemacs-ignore-filter treemacs-ignored-file-predicates)

#+end_src

***** Bindings

#+begin_src emacs-lisp

(cl-loop for binding in '(("M-0"       . treemacs-select-window)
			        ("C-x t 1"   . treemacs-delete-other-windows)
			        ("C-x t t"   . treemacs)
			        ("C-x t d"   . treemacs-select-directory)
			        ("C-x t B"   . treemacs-bookmark)
			        ("C-x t C-t" . treemacs-find-file)
			        ("C-x t M-t" . treemacs-find-tag))
	 do (global-set-key (kbd (car binding)) (cdr binding)))

#+end_src

***** Settings

#+begin_src emacs-lisp

(setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
      treemacs-deferred-git-apply-delay        0.5
      treemacs-directory-name-transformer      #'identity
      treemacs-display-in-side-window          t
      treemacs-eldoc-display                   'simple
      treemacs-file-event-delay                5000
      treemacs-file-extension-regex            treemacs-last-period-regex-value
      treemacs-file-follow-delay               0.2
      treemacs-file-name-transformer           #'identity
      treemacs-follow-after-init               t
      treemacs-expand-after-init               t
      treemacs-find-workspace-method           'find-for-file-or-pick-first
      treemacs-git-command-pipe                ""
      treemacs-goto-tag-strategy               'refetch-index
      treemacs-indentation                     2
      treemacs-indentation-string              " "
      treemacs-is-never-other-window           nil
      treemacs-max-git-entries                 5000
      treemacs-missing-project-action          'ask
      treemacs-move-forward-on-expand          nil
      treemacs-no-png-images                   nil
      treemacs-no-delete-other-windows         t
      treemacs-project-follow-cleanup          nil
      treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
      treemacs-position                        'left
      treemacs-read-string-input               'from-child-frame
      treemacs-recenter-distance               0.1
      treemacs-recenter-after-file-follow      nil
      treemacs-recenter-after-tag-follow       nil
      treemacs-recenter-after-project-jump     'always
      treemacs-recenter-after-project-expand   'on-distance
      treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
      treemacs-show-cursor                     nil
      treemacs-show-hidden-files               t
      treemacs-silent-filewatch                nil
      treemacs-silent-refresh                  nil
      treemacs-sorting                         'alphabetic-asc
      treemacs-select-when-already-in-treemacs 'move-back
      treemacs-space-between-root-nodes        t
      treemacs-tag-follow-cleanup              t
      treemacs-tag-follow-delay                1.5
      treemacs-text-scale                      nil
      treemacs-user-mode-line-format           nil
      treemacs-user-header-line-format         nil
      treemacs-wide-toggle-width               70
      treemacs-width                           35
      treemacs-width-increment                 1
      treemacs-width-is-initially-locked       t
      treemacs-workspace-switch-cleanup        nil)

;; The default width and height of the icons is 22 pixels. If you are
;; using a Hi-DPI display, uncomment this to double the icon size.
;; (treemacs-resize-icons 44)

(treemacs-follow-mode t)
(treemacs-filewatch-mode t)
(treemacs-fringe-indicator-mode 'always)

(pcase (cons (not (null (executable-find "git")))
             (not (null treemacs-python-executable)))
  (`(t . t)
   (treemacs-git-mode 'deferred))
  (`(t . _)
   (treemacs-git-mode 'simple)))

(treemacs-hide-gitignored-files-mode nil)

#+end_src

***** Extensions

#+begin_src emacs-lisp

(straight-use-package 'treemacs-icons-dired)

(straight-use-package 'treemacs-projectile)

(straight-use-package 'treemacs-tab-bar)

(straight-use-package 'treemacs-magit)

#+end_src

** Templates
*** yasnippet
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-yasnippet.el
:END:

#+begin_src emacs-lisp

;; yasnippet
(straight-use-package 'yasnippet)

;; (yas-global-mode 1)

#+end_src

**** <

#+begin_src emacs-lisp

(defun mirage/<-snippet (orig-fun &rest args)
  "Require < before snippets."
  (interactive)
  (setq line (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
	(if (not (string-equal line ""))
	    (if (string-equal (substring line 0 1) "<")
		(progn (save-excursion (move-beginning-of-line nil)
				       (right-char 1)
				       (delete-region (line-beginning-position) (point)))
		       (apply orig-fun args)))))

(advice-add 'yas-expand :around #'mirage/<-snippet)

#+end_src

**** Snippets

#+begin_src emacs-lisp

;; yasnippet-snippets
(straight-use-package 'yasnippet-snippets)

#+end_src


** Applications
*** IDE
**** General
***** Editing
****** Selection
******* expand-region
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-expand-region.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'expand-region)

#+end_src

****** Wrapping
******* embrace
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-embrace.el
:END:

#+begin_src emacs-lisp

;; dependencies
(mirage-module 'expand-region)

;; embrace
(straight-use-package 'embrace)
(global-set-key (kbd "C-,") #'embrace-commander)

(add-hook 'org-mode-hook #'embrace-org-mode-hook)

#+end_src

******* smartparens                                                         :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-smartparens.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'smartparens)

(smartparens-global-mode)

#+end_src

******* paredit                                                               :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-paredit.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'paredit)

#+end_src

***** Outline
****** hideshow
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-hideshow.el
:END:

#+begin_src emacs-lisp

(require 'hideshow)

(add-hook 'prog-mode-hook #'hs-minor-mode)

#+end_src

******* TODO Cycle

- fold back in 1 when no children

#+begin_src emacs-lisp

(defun mirage/hs-cycle (&optional level)
  (interactive "p")
  (save-excursion
    (let (message-log-max (inhibit-message t))
      (if (= level 1)
	  (pcase last-command
	    ('hs-cycle
	     (hs-hide-level 1)
	   (setq this-command 'hs-cycle-children))
	    ('hs-cycle-children
	     ;; TODO: Fix this case. `hs-show-block' needs to be
	     ;; called twice to open all folds of the parent
	     ;; block.
	     (save-excursion (hs-show-block))
	     (hs-show-block)
	     (setq this-command 'hs-cycle-subtree))
	    ('hs-cycle-subtree
	     (hs-hide-block))
	    (_
	     (if (not (hs-already-hidden-p))
		 (hs-hide-block)
	       (hs-hide-level 1)
	       (setq this-command 'hs-cycle-children))))
	(hs-hide-level level)
	(setq this-command 'hs-hide-level)))))

(defun mirage/hs-global-cycle ()
  (interactive)
  (pcase last-command
    ('hs-global-cycle
     (save-excursion (hs-show-all))
     (setq this-command 'hs-global-show))
    (_ (hs-hide-all))))

(define-key hs-minor-mode-map (kbd "C-\\") #'mirage/hs-cycle)

#+end_src

***** Completion
****** company
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-company.el
:END:

#+begin_src emacs-lisp

;; company
(straight-use-package 'company)
(require 'company)

#+end_src

***** Structural editing
******* puni
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-puni.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'puni)

;; specific modes
(dolist (hook '(prog-mode-hook
                tex-mode-hook
                eval-expression-minibuffer-setup-hook))
  (add-hook hook #'puni-mode))

#+end_src

***** Syntax checking
****** flycheck
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-flycheck.el
:END:

#+begin_src emacs-lisp

;; flycheck
(straight-use-package 'flycheck)
(require 'flycheck)

(add-hook 'prog-mode-hook #'flycheck-mode)

#+end_src

***** Language server protocol
****** eglot                                                          :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-eglot.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'eglot)

#+end_src

****** lsp-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-lsp-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'lsp-mode)
(require 'lsp-mode)

#+end_src

****** lsp-bridge                                                     :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-lsp-bridge.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'lsp-bridge)
(require 'lsp-bridge)

#+end_src

**** Specific
***** Lisp
****** rainbow-delimiters
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-rainbow-delimiters.el
:END:

#+begin_src emacs-lisp

;; rainbow-delimieters
(straight-use-package 'rainbow-delimiters)
(require 'rainbow-delimiters)

;; enable rainbow delimiters on all programming modes
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)

#+end_src

***** Python
****** elpy
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-elpy.el
:END:

#+begin_src bash :tangle no

sudo apt-get install python3-venv

#+end_src

#+begin_src emacs-lisp

;; elpy
(straight-use-package 'elpy)
(elpy-enable)

#+end_src

******* RPC

#+begin_src emacs-lisp

(setq elpy-rpc-timeout 5)

(setq elpy-rpc-backend "jedi")

(setq elpy-rpc-python-command "python3")

#+end_src

******* Navigation

#+begin_src emacs-lisp

(define-key elpy-mode-map (kbd "C-M-n") 'elpy-nav-forward-block)
(define-key elpy-mode-map (kbd "C-M-p") 'elpy-nav-backward-block)

#+end_src

***** Matlab
****** matlab-emacs
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-matlab-emacs.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(matlab-emacs :type git :host nil :repo "https://git.code.sf.net/p/matlab-emacs/src"))
(load-library "matlab-load")

(add-to-list 'auto-mode-alist '("\\.m$" . matlab-mode))

#+end_src

***** Rust
****** rustic
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-rustic.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'rustic)

;; Do not format org-babel blocks after a successful build
(setq rustic-babel-format-src-block nil)
;; Do not display compilation buffer of babel process
(setq rustic-babel-display-compilation-buffer nil)

;; Add cargo to exec-path
(add-to-list 'exec-path "~/.cargo/bin")

#+end_src

*** PDF
**** pdf-tools
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-pdf-tools.el
:END:

#+begin_src emacs-lisp

;; requirements
(mirage-module 'tablist)

(straight-use-package 'pdf-tools)
(pdf-tools-install)
(pdf-loader-install)
(require 'pdf-tools)

;; page switching
(define-key pdf-view-mode-map (kbd "<up>")    #'pdf-view-previous-line-or-previous-page)
(define-key pdf-view-mode-map (kbd "<down>")  #'pdf-view-next-line-or-next-page)
(define-key pdf-view-mode-map (kbd "<left>")  #'pdf-view-previous-page)
(define-key pdf-view-mode-map (kbd "<right>") #'pdf-view-next-page)

;; replace swiper
(define-key pdf-view-mode-map (kbd "C-s") #'isearch-forward)

;; page display size
(setq-default pdf-view-display-size 'fit-page)
;; automatically annotate highlights
(setq pdf-annot-activate-created-annotations t)

;; [c]enter
(define-key pdf-view-mode-map (kbd "c") #'pdf-view-center-in-window)
;; [j]ump 
(define-key pdf-view-mode-map (kbd "j") #'pdf-view-goto-label)
;; [h]highlight
(define-key pdf-view-mode-map (kbd "h") #'pdf-annot-add-highlight-markup-annotation)
;; [t]ext annotation
(define-key pdf-view-mode-map (kbd "t") #'pdf-annot-add-text-annotation)
;; [d]elete annotation
(define-key pdf-view-mode-map (kbd "d") #'pdf-annot-delete)
;; lateral scrolling
(define-key pdf-view-mode-map (kbd "S-<wheel-up>")   #'image-forward-hscroll)
(define-key pdf-view-mode-map (kbd "S-<wheel-down>") #'image-backward-hscroll)

;; themed view
(define-key pdf-view-mode-map (kbd "C-c C-r t") #'pdf-view-themed-minor-mode)
;; fine-grained zooming
(setq pdf-view-resize-factor 1.1)

#+end_src

**** pdf-view-restore
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-pdf-view-restore.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'pdf-view-restore)

(add-hook 'pdf-view-mode-hook #'pdf-view-restore-mode)

#+end_src

*** LaTeX
**** AUCTeX
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-AUCTeX.el
:END:

#+begin_src emacs-lisp

(use-package tex :straight auctex)

#+end_src

*** Org Mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org)
(require 'org)

;; org modules
(require 'org-inlinetask)

#+end_src

**** Patches

#+begin_src emacs-lisp

(require 'el-patch)

#+end_src

***** org-self-insert-command

#+begin_src emacs-lisp

(el-patch-feature org)
(el-patch-defun org-self-insert-command (N)
  "Like `self-insert-command', use overwrite-mode for whitespace in tables.
If the cursor is in a table looking at whitespace, the whitespace is
overwritten, and the table is not marked as requiring realignment."
  (interactive "p")
  (el-patch-remove (org-fold-check-before-invisible-edit 'insert))
  (cond
   ((and org-use-speed-commands
	 (let ((kv (this-command-keys-vector)))
	   (setq org-speed-command
		 (run-hook-with-args-until-success
		  'org-speed-command-hook
		  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp org-speed-command)
      (setq this-command org-speed-command)
      (call-interactively org-speed-command))
     ((functionp org-speed-command)
      (funcall org-speed-command))
     ((consp org-speed-command)
      (eval org-speed-command t))
     (t (let (org-use-speed-commands)
	  (call-interactively 'org-self-insert-command)))))
   ((and
     (= N 1)
     (not (org-region-active-p))
     (org-at-table-p)
     (progn
       ;; Check if we blank the field, and if that triggers align.
       (and (featurep 'org-table)
	    org-table-auto-blank-field
	    (memq last-command
		  '(org-cycle org-return org-shifttab org-ctrl-c-ctrl-c))
	    (if (or (eq (char-after) ?\s) (looking-at "[^|\n]*  |"))
		;; Got extra space, this field does not determine
		;; column width.
		(let (org-table-may-need-update) (org-table-blank-field))
	      ;; No extra space, this field may determine column
	      ;; width.
	      (org-table-blank-field)))
       t)
     (looking-at "[^|\n]*  |"))
    ;; There is room for insertion without re-aligning the table.
    (self-insert-command N)
    (org-table-with-shrunk-field
     (save-excursion
       (skip-chars-forward "^|")
       ;; Do not delete last space, which is
       ;; `org-table-separator-space', but the regular space before
       ;; it.
       (delete-region (- (point) 2) (1- (point))))))
   (t
    (setq org-table-may-need-update t)
    (self-insert-command N)
    (org-fix-tags-on-the-fly)
    (when org-self-insert-cluster-for-undo
      (if (not (eq last-command 'org-self-insert-command))
	  (setq org-self-insert-command-undo-counter 1)
	(if (>= org-self-insert-command-undo-counter 20)
	    (setq org-self-insert-command-undo-counter 1)
	  (and (> org-self-insert-command-undo-counter 0)
	       buffer-undo-list (listp buffer-undo-list)
	       (not (cadr buffer-undo-list)) ; remove nil entry
	       (setcdr buffer-undo-list (cddr buffer-undo-list)))
	  (setq org-self-insert-command-undo-counter
		(1+ org-self-insert-command-undo-counter))))))))

#+end_src

***** TODO org-indent--compute-prefixes

- el-patch

#+begin_src emacs-lisp

(defun mirage/org-indent--compute-prefixes ()
  "Recompute line prefixes for regular text to
match the indentation of the parent heading."
  (dotimes (n org-indent--deepest-level)
      (let ((indentation (if (= n 0) 0 1)))
        (aset org-indent--text-line-prefixes
	        n
	        (org-add-props
	           (concat (make-string (+ n indentation) ?\s))
		    nil 'face 'org-indent)))))

(advice-add 'org-indent--compute-prefixes :after #'mirage/org-indent--compute-prefixes)

#+end_src

**** UI
***** org-modern
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-modern.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-modern)

(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)

#+end_src

****** Lists
******* Markers

#+begin_src emacs-lisp

(setq org-modern-list '((?+ . "-")
 		  	(?- . "•")
 			(?* . "▶")))

#+end_src

******* Checkboxes

#+begin_src emacs-lisp

(setq org-modern-checkbox nil)

#+end_src

****** Tables

#+begin_src emacs-lisp

;; Vertical table line width
(setq org-modern-table-vertical 1)

;; Horizontal table line width
(setq org-modern-table-horizontal 1)

#+end_src

****** Highlights

#+begin_src emacs-lisp

;; Tags
(setq org-modern-tag nil)

;; Priorities
(setq org-modern-priority nil)

#+end_src

***** org-appear
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-appear.el
:END:

#+begin_src emacs-lisp

(setq org-hide-emphasis-markers t)

(setq org-hidden-keywords '(title))

;; org-appear
(straight-use-package '(org-appear :type git :host github :repo "awth13/org-appear"))
(add-hook 'org-mode-hook 'org-appear-mode)

;; links
(setq org-appear-autolinks t)

;; keywords
(setq org-appear-autokeywords t)

;; symbols
(setq org-appear-autoentities t)

;; subscripts and superscripts
(setq org-appear-autosubmarkers t)
(setq org-appear-inside-latex t)

#+end_src

***** org-fragtog
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-fragtog.el
:END:

#+begin_src emacs-lisp

;; org-fragtog
(straight-use-package 'org-fragtog)
(require 'org-fragtog)

(add-hook 'org-mode-hook 'org-fragtog-mode)

#+end_src

**** Editing
***** org-paragraph
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-paragraph.el
:END:

#+begin_src emacs-lisp

(require 'org-paragraph (concat user-emacs-directory "elisp/packages/org-paragraph.el"))

#+end_src

****** org-meta-arrows-h

#+begin_src emacs-lisp

(defun mirage/org-meta-arrows-h (orig-fun &rest args)
  "Paragraph indentation with `org-meta<arrows>'.
Furthermore, if a region is active and its
beginning lies on an Org Mode heading,
`mirage/org-command-expand-region' to execute ORIG-FUN."
  (interactive)
  (cond ((mirage/org-relative-line-paragraph) (mirage/org-paragraph orig-fun args))
	((region-active-p)                    (mirage/org-indent-region orig-fun args))
	(t                                    (apply orig-fun args))))

(advice-add 'org-metaleft  :around #'mirage/org-meta-arrows-h)
(advice-add 'org-metaright :around #'mirage/org-meta-arrows-h)

#+end_src

****** TODO org-meta-arrows-v

- paragraphs
- visibility change when heading visibility is CHILDREN
   - save previous visibility
      - mirage/org-subtree-state
         - overlay = overlays-in subtree-beg subtree-end
         - overlay-properties?
   - org-meta-v
   - if post visibility is not equal to previous
      - cycle back to previous visibility
   - rough
      - visibility change -> assume prev was CHILDREN -> 2 x org-cycle-internal-local

#+begin_src emacs-lisp

(defun mirage/org-meta-arrows-v (orig-fun &rest args)
  (interactive)
  (if (mirage/org-at-ellipsis)
      (progn (beginning-of-visual-line) (end-of-line)))
  (apply orig-fun args)
  (if (mirage/org-relative-line-heading-folded)
      (outline-hide-subtree)))

(advice-add 'org-metaup   :around #'mirage/org-meta-arrows-v)
(advice-add 'org-metadown :around #'mirage/org-meta-arrows-v)

#+end_src

***** org-download
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-download.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-download)

(dolist (mode '(org-mode-hook
		dired-mode-hook))
  (add-hook mode #'org-download-enable))

;; download directory
(setq-default org-download-image-dir "./figures")

;; customize #+DOWNLOADED attribute
(defun mirage/org-download-annotate (link)
  "Create a captioned and labeled figure."
  (concat "#+CAPTION:\n"
          "#+NAME: fig:\n"))
(setq org-download-annotate-function #'mirage/org-download-annotate)

#+end_src

**** Templates
***** org-tempo
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-tempo.el
:END:

#+begin_src emacs-lisp

;; required as of Org 9.2
(require 'org-tempo)

;; navigation
(define-key org-mode-map (kbd "C-c f") #'tempo-forward-mark)
(define-key org-mode-map (kbd "C-c b") #'tempo-backward-mark)

;; inhibit electric-pair completion of <
(add-hook 'org-mode-hook
          (lambda () (setq-local electric-pair-inhibit-predicate
                                 `(lambda (c) (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))

#+end_src

****** LaTeX

#+begin_src emacs-lisp

;; equations
(tempo-define-template "latex-equation"
		          '("#+NAME: eq:" p n
			    "\\begin{equation}" n
			    p n
			    "\\end{equation}" >)
			  "<eq"
			  "LaTeX equation template")

(tempo-define-template "latex-derivation"
		          '("#+NAME: eq:" p n
			    "\\begin{equation}" n
			    "\\arraycolsep=3pt\\def\\arraystretch{2.25}" n
			    "\\begin{array}{lll}" n
			    p n
			    "\\end{array}" n
			    "\\end{equation}" >)
			  "<de"
			  "LaTeX derivation template")

#+end_src

****** Figures

#+begin_src emacs-lisp

;; figures
(tempo-define-template "fig"
		       '("#+NAME: fig:" p n
			 "#+CAPTION: " p n
			 "#+ATTR_ORG: :width 450" n
			 "[[./" p "]]" >)
		       "<fig"
		       "Org Mode figure template")

#+end_src

****** Code blocks

#+begin_src emacs-lisp

(defun mirage/tempo-code-block (key language)
  (tempo-define-template language
		         `("#+begin_src " ,language n
			   n
			   p n
			   n
			   "#+end_src" >)
			 key
			 language))

(dolist (pair '(("<sh"   "shell")
		("<el"   "emacs-lisp")
		("<py"   "python")
                ("<rs"   "rust")
                ("<cpp"  "C++")
		("<bash" "bash")
                ("<tx"   "latex")))
  (apply 'mirage/tempo-code-block pair))

#+end_src

***** org-capture
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-capture.el
:END:

#+begin_src emacs-lisp

(require 'org-capture)

#+end_src

****** TODO Templates

- lecture
   - specify directory
   - template

**** Applications
***** Notes
****** bitacora
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-bitacora.el
:END:

#+begin_src emacs-lisp

(require 'bitacora (concat user-emacs-directory "elisp/packages/bitacora.el"))

#+end_src

****** org-roam
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-roam.el
:END:

Importantly, [[https://org-roam.discourse.group/t/no-emacsql-sqlite-binary-available-aborting-error-when-installing-org-roam-v2-on-mac/2178/6][a C compiler (eg: gcc or clang) must be installed for ~emacsql-sqlite~ to install correctly]].

#+begin_src emacs-lisp

;; org-roam
(straight-use-package 'org-roam)

#+end_src

******* Hooks

#+begin_src emacs-lisp

;; node visit hook
(defvar mirage/org-roam-node-visit-hook nil
   "Hook ran after `org-roam-node-visit'.")

(defun mirage/run-org-roam-node-visit-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'mirage/org-roam-node-visit-hook))

;; enable-theme
(advice-add 'org-roam-node-visit :after #'mirage/run-org-roam-node-visit-hook)

#+end_src

******* Startup

#+begin_src emacs-lisp

(if (and (boundp 'org-roam-directory) (file-directory-p org-roam-directory))
    (org-roam-db-autosync-mode))

#+end_src

******* Keymap

#+begin_src emacs-lisp

(setq mirage/org-roam-map (make-keymap))
(global-set-key (kbd "C-r") mirage/org-roam-map)

;; Capture
(define-key mirage/org-roam-map (kbd "c") #'org-roam-capture)

;; Find node
(define-key mirage/org-roam-map (kbd "n") #'org-roam-node-find)

;; Insert reference
(define-key mirage/org-roam-map (kbd "i") #'org-roam-node-insert)

#+end_src

****** org-roam-ui
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-roam-ui.el
:END:

#+begin_src emacs-lisp

;; org-roam-ui
(straight-use-package 'org-roam-ui)

#+end_src

********* Follow

#+begin_src emacs-lisp

(setq org-roam-ui-follow t)

#+end_src

********* Theme

#+begin_src emacs-lisp

;; sync theme and ui
(setq org-roam-ui-sync-theme nil)

#+end_src

********* Startup

#+begin_src emacs-lisp

(setq org-roam-ui-open-on-start nil)

#+end_src

********* Update

#+begin_src emacs-lisp

(setq org-roam-ui-update-on-save t)

#+end_src

****** org-roam-timestamps
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-roam-timestamps.el
:END:

#+begin_src emacs-lisp

;; org-roam-timestamps
(straight-use-package 'org-roam-timestamps)
(require 'org-roam-timestamps)

;; remember
(setq org-roam-timestamps-remember-timestamps nil)
(setq org-roam-timestamps-minimum-gap 3600)

;; visit hook
(add-hook 'mirage/org-roam-node-visit-hook #'org-roam-timestamps-mode)

;; capture hook
(defvar mirage/org-roam-timestamps-mode-active-before-capture nil)

(defun mirage/org-roam-timestamps-mode-off ()
  "Disable `org-roam-timestamps-mode' in Org Roam capture buffers."
  (setq mirage/org-roam-timestamps-mode-active-before-capture org-roam-timestamps-mode)
  (org-roam-timestamps-mode -1))
(add-hook 'org-roam-capture-new-node-hook #'mirage/org-roam-timestamps-mode-off)

(defun mirage/org-roam-timestamps-mode-back ()
  "Re-enable `org-roam-timestamps-mode' after finalizing capture,
if it was previously enabled."
  (if mirage/org-roam-timestamps-mode-active-before-capture
      (org-roam-timestamps-mode)))
(add-hook 'org-capture-after-finalize-hook #'mirage/org-roam-timestamps-mode-back)

#+end_src

***** Agenda
****** org-agenda
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-agenda.el
:END:

#+begin_src emacs-lisp

;; file pre-processing to avoid errors at startup
(let ((files org-agenda-files))
  (dolist (file files)
    (if (not (file-exists-p file))
        (progn (setq org-agenda-files (remove file files))
               (print (concat "WARNING: ignoring nonexistent agenda file: " file))))))

;; org-agenda
(require 'org-agenda)
(global-set-key (kbd "C-c a") #'org-agenda)

;; remove redundant bindings
(define-key org-mode-map (kbd "C-,") nil)

#+end_src

****** org-super-agenda
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-super-agenda.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-super-agenda)
(require 'org-super-agenda)

;; advice
(advice-add 'org-agenda :before (lambda (&rest args) (org-super-agenda-mode 1)))

#+end_src

****** org-rainbow-tags
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-rainbow-tags.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(org-rainbow-tags :type git :host github :repo "KaratasFurkan/org-rainbow-tags"))
(require 'org-rainbow-tags)

(add-hook 'org-mode-hook #'org-rainbow-tags-mode)

(setq org-rainbow-tags-hash-start-index 5)

#+end_src

***** Contacts
****** org-contacts
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-contacts.el
:END:

#+begin_src emacs-lisp

;; org-contacts
(straight-use-package '(org-contacts :type git :host nil :repo "https://repo.or.cz/org-contacts.git"))
(require 'org-contacts)

#+end_src

******* Template

#+begin_src emacs-lisp

(defvar mirage/org-capture-contacts "* %(org-contacts-template-name)
:PROPERTIES:
:ADDRESS: %^{289 Cleveland St. Brooklyn, 11206 NY, USA}
:BIRTHDAY: %^{yyyy-mm-dd}
:EMAIL: %(org-contacts-template-email)
:NOTE: %^{NOTE}
:END:" "org-contacts template")

(add-to-list 'org-capture-templates
   `(("c" "contact" entry
      (file ,(nth 0 org-contacts-files))
      ,mirage/org-capture-contacts)))

#+end_src

***** Calendar
****** org-calendar
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-calendar.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'calfw)
(straight-use-package 'calfw-org)
(straight-use-package 'calfw-ical)

;; org-agenda configuration is lost otherwise
(with-eval-after-load 'org-agenda
  (require 'calfw-org)
  (require 'calfw-ical))

(defun mirage/org-calendar ()
  "Open `calfw' Org Agenda calendar."
  (interactive)
  (require 'org-agenda)
  (let ((inhibit-message t))
       (cfw:open-org-calendar)))

(global-set-key (kbd "C-c c") #'mirage/org-calendar)

#+end_src

***** Programming
****** org-babel
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-babel.el
:END:
******* Editing

#+begin_src emacs-lisp

;; src edit buffer in current window
(setq org-src-window-setup "current-window")

#+end_src

******* Languages

#+begin_src emacs-lisp

;; Language packages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python     . t)
   (C          . t)
   (shell      . t)
   (latex      . t)))

#+end_src

******** Bash

#+begin_src emacs-lisp

(defun org-babel-bash-initiate-session (&optional session _params)
  "Initiate a bash/sh session named SESSION according to PARAMS."
  (org-babel-sh-initiate-session session _params))

#+end_src

******** Python

#+begin_src emacs-lisp

(setq org-babel-python-command "python3")

#+end_src

******* Execution

#+begin_src emacs-lisp

;; suppress security confirmation when evaluating code
(setq org-confirm-babel-evaluate nil)

#+end_src

******* Typesetting
******** Indentation

#+begin_src emacs-lisp

;; Set indentation of code blocks to 0
(setq org-edit-src-content-indentation 0)

;; Indent code blocks appropriately when inside headers
(setq org-src-preserve-indentation     nil)

;; Make code indentation reasonable
(setq org-src-tab-acts-natively        t)

#+end_src

******* Default header arguments

#+begin_src emacs-lisp

(setq org-babel-default-header-args
      '((:noweb   . "yes")
        (:async   . "yes")
        (:session . "ob-session")
        (:results . "replace output")
        (:exports . "code")
        (:cache   . "no")
        (:hlines  . "no")
        (:tangle  . "no")))

#+end_src

****** ox-ipynb
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-ox-ipynb.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(ox-ipynb :type git :host github :repo "jkitchin/ox-ipynb"))
(require 'ox-ipynb)

#+end_src

****** ob-async
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-ob-async.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'ob-async)
(require 'ob-async)

#+end_src

***** Presentations
****** org-reveal
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-reveal.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-reveal)
(require 'ox-reveal)
(load-library "ox-reveal")

(setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")

#+end_src

***** Time-tracking
****** org-pomodoro
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-pomodoro.el
:END:

#+begin_src emacs-lisp

;; org-pomodoro
(straight-use-package 'org-pomodoro)

;; bindings
(define-key org-mode-map (kbd "C-c p") #'org-pomodoro)

;; visual notifications
(setq alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil))))

#+end_src

****** org-agenda-log-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-org-agenda-log-mode.el
:END:

#+begin_src emacs-lisp

;; Org Agenda log mode
(setq org-agenda-start-with-log-mode t)
(setq org-log-done 'time)
(setq org-log-into-drawer t)

#+end_src

*** Tabulated lists
**** tablist
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-tablist.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'tablist)

#+end_src

*** Version control
**** magit
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-magit.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'magit)
(require 'magit)

(global-set-key (kbd "C-x g") #'magit-status)

#+end_src

**** forge
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-forge.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'forge)

#+end_src

*** File management
**** dirvish
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-dirvish.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'dirvish)
(require 'dirvish)

;; override dired
(dirvish-override-dired-mode)

#+end_src


** Extensions
*** crux
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/mirage-crux.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'crux)

#+end_src


* Extensions

Content of an extension:
- Functions
   - If interactive, function bindings
- Macros

** Utilities
*** Get
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-get.el
:END:

**** UI
***** get-active-theme

#+begin_src emacs-lisp

;; Retrieve current theme
(defun mirage/get-active-theme ()
  (substring (format "%s" (nth 0 custom-enabled-themes))))

#+end_src

**** Text
***** get-point

#+begin_src emacs-lisp

(defun mirage/get-point (command &rest args)
  (interactive)
  (save-excursion
    (apply command args)
    (point)))

#+end_src

***** get-last-change

#+begin_src emacs-lisp

(defun mirage/get-last-change ()
  "Retrieve last change in current buffer."
  (setq last-change (nth 1 buffer-undo-list))
  (let ((beg (car last-change))
        (end (cdr last-change)))
    (buffer-substring-no-properties beg end)))

#+end_src

***** count-substrings

#+begin_src emacs-lisp

(defun mirage/count-substrings (regexp str)
  "Return the number of substrings of STR matching REGEXP"
  (loop with start = 0
        for count from 0
        while (string-match regexp str start)
        do (setq start (match-end 0))
        finally return count))

#+end_src

**** Data
***** get-keyword-key-value

#+begin_src emacs-lisp

(defun mirage/get-keyword-key-value (kwd)
   (let ((data (cadr kwd)))
     (list (plist-get data :key)
           (plist-get data :value))))

#+end_src

**** Buffer
***** get-visible-buffers

#+begin_src emacs-lisp

(defun mirage/get-visible-buffers ()
  (cl-delete-duplicates (mapcar #'window-buffer (window-list))))

#+end_src

***** get-buffer-by-file-name

#+begin_src emacs-lisp

(defun mirage/get-buffer-by-file-name (file)
  (cl-loop for buffer in (buffer-list)
	   if (string-equal (buffer-name buffer) (file-name-nondirectory file))
	   return buffer
	   finally return nil))

#+end_src

**** Window
***** get-active-window-number

#+begin_src emacs-lisp

(defun mirage/get-active-window-number ()
  "Retrieve the current window's number."
  (setq window (prin1-to-string (get-buffer-window (current-buffer))))
  (string-match "^[^0-9]*\\([0-9]+\\).*$" window)
  (match-string 1 window))

#+end_src

**** Keymap
***** get-keymaps

#+begin_src emacs-lisp

(defvar mirage/keymap-list '()
  "List containing the symbols of all keymaps in the `obarray'.")

(defun mirage/get-keymaps ()
  "Return a list containing the symbols of all keymaps in the `obarray'."
  (mapatoms (lambda (m) (if (condition-case nil
                                (or (keymapp (symbol-value m))
                                    (keymapp m))
                              (error nil))
                            (add-to-list 'mirage/keymap-list m))
          obarray))
  (when (called-interactively-p 'interactive)
        (message "Keymap list updated, %s keymaps found" (length mirage/keymap-list)))
  mirage/keymap-list)

#+end_src

***** get-keymap-symbol

#+begin_src emacs-lisp

(defun mirage/get-keymap-symbol (keymap)
  "Return the symbol to which KEYMAP is bound, or nil if no such symbol exists."
  (catch 'gotit
    (mapatoms (lambda (sym)
                (and (boundp sym)
                     (eq (symbol-value sym) keymap)
                     (not (eq sym 'keymap))
                     (throw 'gotit sym))))))

#+end_src

-----
References:

- [[https://stackoverflow.com/a/14490054][user4815162342, Answer to "Emacs name of current local keymap?", StackOverflow]]

*** Queries
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-queries.el
:END:

**** At
***** eolp

#+begin_src emacs-lisp

(defun mirage/eolp (orig-fun &rest args)
  (interactive)
  (or (apply orig-fun args) (looking-at-p "[[:blank:]]*$")))

(advice-add 'eolp :around #'mirage/eolp)

#+end_src

***** at-point

#+begin_src emacs-lisp

(defun mirage/at-point (go-to-point &optional point)
  (let ((point (or point (point))))
    (save-excursion
      (funcall go-to-point)
      (= point (point)))))

#+end_src

***** at-indent

#+begin_src emacs-lisp

(defun mirage/at-indent (&optional point)
  (and (mirage/relative-line-indented) (mirage/at-point 'back-to-indentation point)))

#+end_src

**** Line
***** relative-line

#+begin_src emacs-lisp

(defun mirage/relative-line (query &optional number &rest args)
  "Return the result of a boolean query at the beginning
of the current visual line, or another specified by its
relative position to the current line.
Optionally, `args' may be given as input to be passed
to the query at execution."
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-visual-line)
      (beginning-of-line-text (+ number 1))
      (apply query args))))

#+end_src

***** relative-line-regex

#+begin_src emacs-lisp

(defun mirage/relative-line-regex (pattern &optional number)
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-line-text (+ number 1))
      (setq line (buffer-substring-no-properties (mirage/get-point 'beginning-of-line) (mirage/get-point 'end-of-line))))
    (string-match-p pattern line)))

#+end_src

***** relative-line-list

#+begin_src emacs-lisp

(defun mirage/relative-line-list (&optional number)
  (mirage/relative-line-regex "^[[:blank:]]*\\([0-9]+[.\\)]\\{1\\}\\|[-+*]\\{1\\}\\)[[:blank:]]+.*$" number))

#+end_src

***** relative-line-empty

#+begin_src emacs-lisp

(defun mirage/relative-line-empty (&optional number)
  (mirage/relative-line-regex "^[[:space:]]*$" number))

#+end_src

***** TODO relative-line-wrapped

- &optional number

#+begin_src emacs-lisp

(defun mirage/relative-line-wrapped ()
  (> (mirage/get-point 'beginning-of-visual-line) (mirage/get-point 'beginning-of-line-text)))

#+end_src

***** relative-line-indented

#+begin_src emacs-lisp

(defun mirage/relative-line-indented (&optional number)
  (mirage/relative-line-regex "^[[:blank:]]+.*$" number))

  #+end_src

***** relative-line-list-ordered

#+begin_src emacs-lisp

(defun mirage/relative-line-list-ordered (&optional number)
  (mirage/relative-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]+.*$" number))

#+end_src

***** relative-line-list-unordered

#+begin_src emacs-lisp

(defun mirage/relative-line-list-unordered (&optional number)
  (mirage/relative-line-regex "^[[:blank:]]*[-+*]\\{1\\}[[:blank:]]+.*$" number))

#+end_src

**** Region
***** region-blank

#+begin_src emacs-lisp

(defun mirage/region-blank (&optional beg end)
  (let ((beg (or beg (region-beginning)))
	      (end (or end (region-end))))
    (setq region (buffer-substring-no-properties beg end))
    (string-match "\\`[[:space:]]*\\'$" region)))

#+end_src

***** region-multiline-visual

#+begin_src emacs-lisp

(defun mirage/region-multiline-visual ()
  "Return t if a region is active and spans more than one visual line."
  (and (region-active-p) (> (mirage/region-count-visual-lines) 1)))

#+end_src

***** region-count-visual-lines

#+begin_src emacs-lisp

(defun mirage/region-count-visual-lines ()
  "Count visual lines in an active region."
  (interactive)
  (save-excursion 
    (beginning-of-visual-line)
    (count-screen-lines (region-beginning) (region-end))))

#+end_src

*** Execution
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-execution.el
:END:

**** @buffers

#+begin_src emacs-lisp

(defmacro mirage/@buffers (command &optional buffers)
  (let ((buffers (or buffers (buffer-list))))
    `(cl-loop for buffer in ',buffers
              do (if (buffer-live-p buffer)
                     (save-window-excursion
                       (switch-to-buffer buffer)
                       ,command)))))

#+end_src

*** Operators
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-operators.el
:END:

**** <>

#+begin_src emacs-lisp

(defun <> (a b c)
  (and (> b a) (> c b)))

#+end_src


** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-ui.el
:END:

*** Text
**** Theme accents

#+begin_src emacs-lisp

;; accent typefaces
(defvar mirage/accents '(mirage/italic))

(defun mirage/theme-accents (orig-fun &rest args)
  "Many themes will override certain face *attributes*, such as `italic'. To prevent
this, this function loops over all accent typefaces in `mirage/accents', which contains
faces (defined with `defface') named ~mirage/<attribute>~, and makes the ~<attribute>~
inherit from ~mirage/<attribute>~.

As such, when this function is run, the `italic' face attribute will be made to
inherit from `mirage/italic' as in the expression below.

   (set-face-attribute 'italic nil :inherit 'mirage/italic)

Thus, our preferred accent typefaces will stand whatever harassment they may be put
through as a theme loads."
  ;; load theme
  (apply orig-fun args)
  ;; restore accents
  (cl-loop for accent in mirage/accents
	   do (let ((face (intern (car (last (split-string (symbol-name accent) "/"))))))
		     (set-face-attribute face nil :inherit accent))))

(advice-add 'mirage/enable-or-load-theme :around #'mirage/theme-accents)

#+end_src

*** Window
**** Quit

#+begin_src emacs-lisp

(defun mirage/quit-window ()
  (interactive)
  (if current-prefix-arg
      (quit-window)
    (quit-window 1)))

(with-eval-after-load 'helpful
  (cl-loop for map in '(help-mode-map
                        helpful-mode-map)
           do (define-key (symbol-value map) [remap quit-window] #'mirage/quit-window)))

#+end_src

**** Resize
***** window-resize

#+begin_src emacs-lisp

(defun mirage/window-resize (width)
  (window-resize nil (- width (window-width)) t))

#+end_src

***** window-resize-fraction

#+begin_src emacs-lisp

(defun mirage/window-resize-fraction (fr &optional min)
  "Resize window to a fraction of the frame width."
  (interactive)
  (let ((width (max (if min min 0) (truncate (* fr (frame-width))))))
    (window-resize nil (- width (window-width)) t)))

#+end_src

*** Warnings
**** C-g is undefined

#+begin_src emacs-lisp

;; Record last sent message
(defvar last-message nil)
(defadvice message (after my-message pre act) (setq last-message ad-return-value))

(defun mirage/undefined-override (orig-fun &rest args)
  "Override `undefined' function to suppress
undefined key binding messages when interrupting
key binding input with C-g."
  (let ((inhibit-message t)
	    (message-log-max nil))
    (progn (apply orig-fun args)
	       (setq _message last-message)))
  (if (string-match-p (regexp-quote "C-g is undefined") _message)
      (keyboard-quit)
    (message _message)))

;; Override the undefined key binding notice with a keyboard-quit
(advice-add 'undefined :around #'mirage/undefined-override)

#+end_src

*** Mode line
**** Hide

#+begin_src emacs-lisp

(defcustom mirage/mode-line nil
  "Variable containing the format of the hidden mode line")

(defcustom mirage/header-line nil
  "Variable containing the format of the hidden header line")

(defun mirage/hide-mode-line ()
  "Hide `modeline' in current buffer"
  (interactive)
  (let ((m mode-line-format)
        (h header-line-format))
       (mirage/@buffers (if (or m h)
                            (progn (setq mirage/mode-line   m)
                                   (setq mirage/header-line h)
                                   (setq mode-line-format   nil)
                                   (setq header-line-format nil))
                          (progn (setq mode-line-format mirage/mode-line)
                                 (setq header-line-format mirage/header-line))))))

(global-set-key (kbd "M-m") #'mirage/hide-mode-line)

#+end_src

**** Invert

#+begin_src emacs-lisp

(defun mirage/mode-line-invert ()
  (interactive)
  (if mode-line-format
      (mirage/@buffers (progn (set 'header-line-format mode-line-format)
                              (set 'mode-line-format nil)))
    (mirage/@buffers (progn (set 'mode-line-format header-line-format)
                            (set 'header-line-format nil)))))

(global-set-key (kbd "M-t") #'mirage/mode-line-invert)

#+end_src

** Themes
*** Switch
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-theme-switch.el
:END:

**** Load

#+begin_src emacs-lisp

(defun mirage/enable-or-load-theme (theme)
  (condition-case nil
      (enable-theme theme)
    (error (load-theme theme))))

#+end_src

**** Hook

#+begin_src emacs-lisp

(defvar mirage/enable-or-load-theme-hook nil
   "`load-theme' hook.")

(defun mirage/enable-or-load-theme-hook (&rest _args)
   "Run `load-theme-hook'."
   (run-hooks 'mirage/enable-or-load-theme-hook))

(advice-add 'enable-theme :after #'mirage/enable-or-load-theme-hook)
(advice-add 'load-theme   :after #'mirage/enable-or-load-theme-hook)

#+end_src

**** Toggle

#+begin_src emacs-lisp

(defun mirage/theme-toggle ()
  "Toggle between `dark' and `light' themes
using `enable-theme'"
  (interactive)
  (let ((theme (nth 0 custom-enabled-themes)))
    (cond ((string-equal theme light-theme) (progn (disable-theme light-theme)
					           (mirage/enable-or-load-theme dark-theme)))
	  (t                                (progn (disable-theme dark-theme)
					           (mirage/enable-or-load-theme light-theme))))))

(global-set-key (kbd "C-t") #'mirage/theme-toggle)

#+end_src

**** Light and dark

#+begin_src emacs-lisp

(defcustom mirage/light-dark-themes '("modus"
                                      "nano")
  "Themes with light and dark versions.")

(defcustom mirage/theme-advice-dark '()
  "List of functions run when loading the `dark' theme, if it is ncluded in `mirage/light-dark-themes'.")

(defcustom mirage/theme-advice-light '()
  "List of functions run when loading the `light' theme, if it is ncluded in `mirage/light-dark-themes'.")

(defun mirage/theme-specific-advice (orig-fun &rest args)
  "Apply theme-specific advice when enabling themes, and
preserve modeline status through theme changes."
  (setq modeline-status mode-line-format)
  (apply orig-fun args)
  (let ((theme (nth 0 args)))
    (if (string-match-p (string-join mirage/light-dark-themes "\\|") (symbol-name theme))
        (let ((advice-list (if (string-equal theme light-theme)
                               mirage/theme-advice-light
                             mirage/theme-advice-dark)))
          (dolist (advice advice-list)
            (funcall advice))))
  (setq mode-line-format modeline-status)))

;; add
(advice-add 'enable-theme :around #'mirage/theme-specific-advice)
(advice-add 'load-theme   :around #'mirage/theme-specific-advice)

#+end_src

**** Line numbers

#+begin_src emacs-lisp

(defvar mirage/dark-line-number-colors '("#cfcfcf" "#262626")
  "Line number HTML colors for dark themes: FOREGROUND, BACKGROUND")

(defvar mirage/light-line-number-colors '("#878787" "#ededed")
  "Line number HTML colors for light themes: FOREGROUND, BACKGROUND")

(defun mirage/line-number-set-colors (fg bg)
  "Set the foreground (FG) and background (BG) colors of the line numbers
displayed by `display-line-numbers-mode'."
  (set-face-attribute 'line-number nil :foreground fg :background bg))

(defun mirage/set-dark-line-number-colors ()
  (apply 'mirage/line-number-set-colors mirage/dark-line-number-colors))

(defun mirage/set-light-line-number-colors ()
  (apply 'mirage/line-number-set-colors mirage/light-line-number-colors))

(add-to-list 'mirage/theme-advice-dark  #'mirage/set-dark-line-number-colors)
(add-to-list 'mirage/theme-advice-light #'mirage/set-light-line-number-colors)

;; reload active theme
(let ((active-theme (car custom-enabled-themes)))
  (if active-theme (enable-theme active-theme)))

#+end_src

*** Mode line
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-theme-modeline.el
:END:

#+begin_src emacs-lisp

(defun mirage/modeline-set-colors (fg fg-in bg bg-in)
  "Set the color of the mode and header lines and blend the 
`doom-modeline-bar' with the background."
  (set-face-attribute 'mode-line            nil :foreground fg    :background bg    :box nil)
  (set-face-attribute 'mode-line-inactive   nil :foreground fg-in :background bg-in :box nil)
  ;; header line
  (set-face-attribute 'header-line          nil :foreground fg-in :background bg-in :box nil))

(defvar mirage/dark-modeline-colors '("#cfcfcf" "#cfcfcf" "#454545" "#242424")
  "Dark modeline HTML colors: FOREGROUND, FOREGROUND-INACTIVE, BACKGROUND, BACKGROUND-INACTIVE")

(defvar mirage/light-modeline-colors '("#616161" "#878787" "#c4c4c4" "#ededed")
  "Light modeline HTML colors: FOREGROUND, FOREGROUND-INACTIVE, BACKGROUND, BACKGROUND-INACTIVE")

(defun mirage/set-dark-modeline-colors ()
  (apply 'mirage/modeline-set-colors mirage/dark-modeline-colors))

(defun mirage/set-light-modeline-colors ()
  (apply 'mirage/modeline-set-colors mirage/light-modeline-colors))

(add-to-list 'mirage/theme-advice-dark  #'mirage/set-dark-modeline-colors)
(add-to-list 'mirage/theme-advice-light #'mirage/set-light-modeline-colors)

;; reload active theme
(let ((active-theme (car custom-enabled-themes)))
  (if active-theme (enable-theme active-theme)))

#+end_src


** Input
*** RSI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-rsi.el
:END:

#+begin_src emacs-lisp

;; requirements
(pixel-scroll-precision-mode)
(mirage-module 'pdf-tools)

;; save-buffer
(global-set-key (kbd "C-=") #'save-buffer)
(global-set-key (kbd "C-x C-s") nil)

;; buffer selection
(global-unset-key (kbd "C-x b"))
(global-set-key (kbd "<menu>") #'switch-to-buffer)

;; buffer switching
(global-unset-key (kbd "C-x <right>"))
(global-unset-key (kbd "C-x <left>"))
(cl-loop for map in (list
                     global-map
                     ;; plus mode maps that override the keys
                     pdf-view-mode-map
                     pixel-scroll-precision-mode-map)
         do (define-key map (kbd "<next>")  #'next-buffer)
         do (define-key map (kbd "<prior>") #'previous-buffer))

#+end_src

** Editing
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-editing.el
:END:

*** Delete
**** Line

#+begin_src emacs-lisp

(defun mirage/delete-line ()
  (delete-region (mirage/get-point 'beginning-of-line) (mirage/get-point 'end-of-line)))

#+end_src

**** Word

Do not save whole killed words in kill ring.

#+begin_src emacs-lisp

(defun mirage/delete-word-forward (&optional arg)
  (interactive)
  (delete-region (point) (progn (forward-word arg) (point))))

(defun mirage/delete-word-backward (&optional arg)
  (interactive)
  (delete-region (point) (progn (backward-word arg) (point))))

(global-set-key (kbd "C-<delete>") #'mirage/delete-word-forward)
(global-set-key (kbd "C-<backspace>")  #'mirage/delete-word-backward)

#+end_src

**** Hungry

#+begin_src emacs-lisp

(defun mirage/@delete-hungry (query)
  "Conditional region deletion.

Default: `delete-region'

If region starts at the beginning of an
indented line, delete region and indent.

If `query', delete the region and its indent 
plus one character."
  (setq beg (region-beginning) end (region-end))
  (if (mirage/at-indent beg)
	    (save-excursion (beginning-of-visual-line)
                      (if (and query (not (bobp)) (not (mirage/relative-line-empty -1)))
                          (left-char))
                      (delete-region (point) end))
    (delete-region beg end)))

(defun mirage/delete-hungry ()
  "If the region starts at the beginning of an 
indented line and the current mode is derived from 
`prog-mode',  delete the region and its indent plus 
one character."
  (interactive)
  (mirage/@delete-hungry (derived-mode-p 'prog-mode)))

#+end_src

**** TODO Forward

- region deletion

#+begin_src emacs-lisp

(defun mirage/nimble-delete-forward ()
  "Conditional forward deletion.

Default: `delete-forward-char' 1

If next line is empty, forward delete indent of 
next line plus one character."
  (interactive)
  (cond ((and (eolp) (mirage/relative-line-indented 1)) (progn (setq beg (point)) (next-line) (back-to-indentation) (delete-region beg (point))))
	    ((mirage/relative-line-empty)                   (delete-region (point) (mirage/get-point 'next-line)))
	    (t                                              (delete-forward-char 1))))

(global-set-key (kbd "<delete>") #'mirage/nimble-delete-forward)

#+end_src

**** Backward

#+begin_src emacs-lisp

(defun mirage/nimble-delete-backward ()
  "Conditional forward deletion.

Default: `delete-backward-char' 1

If `multiple-cursors-mode' is active, `delete-backward-char' 1.

If region is active, delete region.

If cursor lies either `mirage/at-indent' or is preceded only by
whitespace, delete region from `point' to `beginning-of-visual-line'."
  (interactive)
  (if (not (bound-and-true-p multiple-cursors-mode))
      (cond ((and (region-active-p) (not (mirage/region-blank))) (mirage/delete-hungry))
	    ((mirage/at-indent)                                  (delete-region (point) (mirage/get-point 'beginning-of-visual-line)))
	    (t                                                   (delete-backward-char 1)))
    (delete-backward-char 1)))

(global-set-key (kbd "<backspace>") #'mirage/nimble-delete-backward)

#+end_src

*** Kill ring
**** Size

#+begin_src emacs-lisp

;; Increase kill ring size
(setq kill-ring-max 200)

#+end_src

**** Mouse

#+begin_src emacs-lisp

(defun mirage/kill-ring-mouse ()
  "If a region is active, save the region to the
kill ring. Otherwise, yank the last entry in the
kill ring."
  (interactive)
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (yank)))

(global-set-key   (kbd "<mouse-3>") #'mirage/kill-ring-mouse)
(global-unset-key (kbd "<down-mouse-3>"))

#+end_src

*** TODO Regions

- insert-char in region
   - delete, insert char
- arrow exit
   - <right> -> right of region
   - <left>  -> left of region

*** Selection
**** Defaults

#+begin_src emacs-lisp

;; Unset secondary overlay key bindings
(global-unset-key [M-mouse-1])
(global-unset-key [M-drag-mouse-1])
(global-unset-key [M-mouse-3])
(global-unset-key [M-mouse-2])

#+end_src

*** TODO Comments

- if region is active and cursor is in empty line, region is not commented
- if last arrow command was up or left, move up, if last arrow command was right or down, move down

#+begin_src emacs-lisp

(defun mirage/smart-comment ()
  "If a region is active, comment out all lines in the
region. Otherwise, comment out current line if it is
not empty. In any case, advance to next line."
  (interactive)
  (let (beg end)
    ;; If a region is active
    (if (region-active-p)
	      ;; If the beginning and end of the region are in
	      ;; the same line, select entire line
	      (if (= (count-lines (region-beginning) (region-end)) 1)
		  (setq beg (line-beginning-position) end (line-end-position))
		;; Else, select region from the start of its first
		;; line to the end of its last.
		(setq beg (save-excursion (goto-char (region-beginning)) (line-beginning-position))
		      end (save-excursion (goto-char (region-end)) (line-end-position))))
      ;; Else, select line
      (setq beg (line-beginning-position) end (line-end-position)))

    ;; Comment or uncomment region
    ;; If Org Mode is active
    (if (not (mirage/relative-line-empty))
	      (comment-or-uncomment-region beg end))
    ;; Move to the beginning of the next line
    (beginning-of-line-text 2)))

(global-set-key (kbd "C-x ;") #'mirage/smart-comment)

#+end_src

*** Rectangular regions

#+begin_src emacs-lisp

;; Ensure rectangular-region-mode is loaded
(require 'rectangular-region-mode)

#+end_src

**** Mouse rectangle

#+begin_src emacs-lisp

;; Multiple cursor rectangle definition mouse event
(defun mirage/mouse-rectangle (start-event)
  (interactive "e")
  (deactivate-mark)
  (mouse-set-point start-event)
  (set-rectangular-region-anchor)
  (rectangle-mark-mode +1)
  (let ((drag-event))
    (track-mouse
      (while (progn
               (setq drag-event (read-event))
               (mouse-movement-p drag-event))
        (mouse-set-point drag-event)))))

(global-set-key (kbd "M-<down-mouse-1>") #'mirage/mouse-rectangle)

#+end_src

**** TODO Multiple cursors

- arrow exit
   - <right>
      - right
   - <left>
      - left

#+begin_src emacs-lisp

;; Enter multiple-cursors-mode
(defun mirage/rectangular-region-multiple-cursors ()
  (interactive)
  (rectangular-region-mode 0)
  (multiple-cursors-mode 1)
  (deactivate-mark)
  (mc/for-each-fake-cursor
   (if (invisible-p (marker-position (overlay-get cursor 'point)))
       (mc/remove-fake-cursor cursor))))

(define-key rectangular-region-mode-map (kbd "<return>") #'mirage/rectangular-region-multiple-cursors)

#+end_src

**** Quit

#+begin_src emacs-lisp

;; Exit rectangular-region-mode
(define-key rectangular-region-mode-map (kbd "<escape>") #'rrm/keyboard-quit)
(define-key rectangular-region-mode-map (kbd "<mouse-1>") #'rrm/keyboard-quit)

#+end_src

** Search
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-search.el
:END:
*** Search and replace

#+begin_src emacs-lisp

(defun mirage/query-replace-regexp ()
  (interactive)
  (save-excursion
    (beginning-of-buffer)
    (call-interactively 'query-replace-regexp)))

(global-set-key (kbd "M-/") #'mirage/query-replace-regexp)

#+end_src

** Workflow
*** Session
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-session.el
:END:

#+begin_src emacs-lisp

(defun mirage/load-session ()
  (interactive)
  (let ((session (read-file-name "Select session: "
                                 "~/sessions/"
                                 nil
                                 nil
                                 (car (directory-files "~/sessions/" nil "\\`[^.]*\\'")))))
    (desktop-change-dir session)
    (wg-load (concat session ".wg"))
    (call-interactively 'wg-switch-to-workgroup)))

(global-set-key (kbd "C-x s") #'mirage/load-session)

#+end_src

*** External programs
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-external-programs.el
:END:
**** Keymap
#+begin_src emacs-lisp

(defcustom mirage/external-application-map (make-keymap)
  "External application keymap")

(defcustom mirage/external-application-bindings '()
  "List of external application key-binding pairs")

(defun mirage/bind-external-application (binding)
  (add-to-list 'mirage/external-application-bindings binding))

(global-set-key (kbd "C-c C-o") mirage/external-application-map)

#+end_src

**** Codium

#+begin_src emacs-lisp

(defun open-in-codium ()
  (interactive)
  (let ((root (projectile-root-bottom-up (file-name-directory buffer-file-name))))
    (call-process-shell-command (concat "codium " root "&") nil 0)))

(mirage/bind-external-application '("c" . open-in-codium))

#+end_src

**** Firefox

#+begin_src emacs-lisp

(defun open-in-firefox ()
  (interactive)
  (call-process-shell-command (concat "firefox-trunk \"" (buffer-file-name) "\"") nil 0))

(mirage/bind-external-application '("f" . open-in-firefox))

#+end_src

**** Binding definition

#+begin_src emacs-lisp

(dolist (binding mirage/external-application-bindings)
  (define-key mirage/external-application-map (kbd (car binding)) (cdr binding)))

#+end_src


** Navigation
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-navigation.el
:END:

*** Text
**** TODO end

- in wrapped line
   - end of visual line -> end of line
- else
   - end of line -> end of visual line

#+begin_src emacs-lisp

;; Double end to go to the beginning of line
(defvar mirage/double-end-timeout 0.4)

(defun mirage/double-end ()
  "Move to end of visual line. If the command is repeated 
within `mirage/double-end-timeout' seconds, move to end
of line."
  (interactive)
  (let ((last-called (get this-command 'mirage/last-call-time)))
    (if (and (eq last-command this-command)
             (<= (time-to-seconds (time-since last-called)) mirage/double-end-timeout))
        (progn (beginning-of-visual-line) (end-of-line))
      (end-of-visual-line)))
  (put this-command 'mirage/last-call-time (current-time)))

(global-set-key (kbd "<end>") #'mirage/double-end)

#+end_src

**** home

#+begin_src emacs-lisp

(defun mirage/home ()
  "Conditional homing. 

Default: `beginning-of-line-text'

If the current line is empty, home to `beginning-of-line'.

If the current line holds a list item, home back to `beginning-of-line-text'.

If the current line is indented, home `back-to-indentation'.

If the current mode is derived from `prog-mode', home `back-to-indentation'.

If the current line is a wrapped visual line, home to
`beginning-of-visual-line'."
  (interactive)
  (cond ((mirage/relative-line-empty)    (beginning-of-line))
	((mirage/relative-line-list)     (beginning-of-line-text))
	((mirage/relative-line-indented) (back-to-indentation))
	((mirage/relative-line-wrapped)  (beginning-of-visual-line))
	((derived-mode-p 'prog-mode)     (back-to-indentation))
	((mirage/relative-line-wrapped)  (beginning-of-visual-line))
        (t                               (beginning-of-line-text))))

(defvar mirage/double-home-timeout 0.4)

(defun mirage/double-home ()
  "Dynamic homing command with a timeout of `mirage/double-home-timeout' seconds.
- Single press: `mirage/home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'mirage/last-call-time)))
    (if (and (eq last-command this-command)
	     (<= (time-to-seconds (time-since last-called)) mirage/double-home-timeout))
	(progn (beginning-of-visual-line)
	       (beginning-of-line-text))
      (mirage/home)))
  (put this-command 'mirage/last-call-time (current-time)))

(global-set-key (kbd "<home>") #'mirage/double-home)

#+end_src

**** previous-line

#+begin_src emacs-lisp

(defun mirage/previous-line (orig-fun &rest args)
  "If a region is active and either the current mode is derived from
`prog-mode' or the cursor lies in an `org-babel' source code block,
arrow-up to `end-of-visual-line' of `previous-line'."
  (apply orig-fun args)
  (if (and (region-active-p)
           (or (derived-mode-p 'prog-mode)
               (and (string-equal major-mode "org-mode") (org-in-src-block-p))))
      (progn (point-to-register 'region-up-register)
             (end-of-visual-line))))

(advice-add 'previous-line :around #'mirage/previous-line)

(defun mirage/region-up-register ()
  "Move cursor to `region-up-register', defined in
`mirage/previous-line'."
  (interactive)
  (let ((end (region-end)))
    (ignore-errors (jump-to-register 'region-up-register))
    (set-register 'region-up-register nil)
    (push-mark end)))

(global-set-key (kbd "S-<home>") #'mirage/region-up-register)

#+end_src

**** beginning-of-line-text

#+begin_src emacs-lisp

(defun mirage/beginning-of-line-text (orig-fun &rest args)
  "Correctly go to `beginning-of-line-text' in numbered lists."
  (interactive)
  (let ((ordered-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]\\{1\\}"))
    (if (save-excursion (beginning-of-line)
			    (looking-at-p ordered-line-regex))
	    (progn (beginning-of-line)
		   (re-search-forward ordered-line-regex))
      (apply orig-fun args))))

(advice-add 'beginning-of-line-text :around #'mirage/beginning-of-line-text)

#+end_src

*** Window
**** Split and follow

#+begin_src emacs-lisp

;; split and follow
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (other-window 1))
(global-set-key (kbd "C-x 2") #'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (other-window 1))
(global-set-key (kbd "C-x 3") #'split-and-follow-vertically)

#+end_src

**** Previous window
***** Record

#+begin_src emacs-lisp

(defvar mirage/window-previous nil
  "Selected window before the last window change.")

(defvar mirage/window-pre-command nil
  "Auxiliary variable containing the `selected-window'
before the execution of any command.")

(defun mirage/record-window-pre-command ()
  (setq mirage/window-pre-command (selected-window)))
(add-hook 'pre-command-hook #'mirage/record-window-pre-command)

(defun mirage/record-window-previous ()
  (let ((window-post (selected-window)))
    (if (not (eq window-post mirage/window-pre-command))
	      (setq mirage/window-previous mirage/window-pre-command))))
(add-hook 'post-command-hook #'mirage/record-window-previous)

#+end_src

***** TODO Command

- if single window, do nothing

#+begin_src emacs-lisp

(defun mirage/goto-window-previous ()
  (interactive)
  (let ((target  mirage/window-previous)
	      (current (selected-window)))
    (if target
	      (progn (select-window target)
		     (setq mirage/window-previous current)))))

(global-set-key (kbd "C-p") #'mirage/goto-window-previous)

#+end_src


** File management
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-file-management.el
:END:

*** Buffer
**** Reload from disk

#+begin_src emacs-lisp

(defun mirage/reload-from-disk (&optional buffer)
  "Revert BUFFER contents to the contents of its
file saved on disk, ignoring the auto-save file.
If the buffer has unsaved modifications, prompt
the user for confirmation."
  (interactive)
  (let ((buffer (or buffer (current-buffer))))
    (save-window-excursion
      (switch-to-buffer buffer)
      (if (not (buffer-modified-p))
	     (revert-buffer t t)
	   (revert-buffer t nil)))))

(global-set-key (kbd "C-c r") #'mirage/reload-from-disk)

#+end_src

*** Batch processing
**** DOS to UNIX

#+begin_src emacs-lisp

;; Transform all files in directory from DOS to Unix line breaks
(defun mirage/dos2unix (&optional dir)
  (let ((default-directory (or dir (file-name-directory buffer-file-name))))
    (shell-command "find . -maxdepth 1 -type f -exec dos2unix \\{\\} \\;")))

#+end_src


** PDF
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-pdf.el
:END:
*** Jump

#+begin_src emacs-lisp

(defun mirage/pdf-view-jump-to-top ()
  (interactive)
  (image-previous-line 9999))

(defun mirage/pdf-view-jump-to-bottom ()
  (interactive)
  (image-next-line 9999))

(define-key pdf-view-mode-map (kbd "<home>") #'mirage/pdf-view-jump-to-top)
(define-key pdf-view-mode-map (kbd "<end>")  #'mirage/pdf-view-jump-to-bottom)

#+end_src

*** Scroll

#+begin_src emacs-lisp

(defun mirage/pdf-view-next-line (&optional arg)
  "Scroll upward by ARG lines. Stay in page."
  (interactive "P")
  (image-next-line (if arg arg 1)))

(defun mirage/pdf-view-previous-line (&optional arg)
  "Scroll upward by ARG lines. Stay in page."
  (interactive "P")
  (image-next-line (if arg (* -1 arg) -1)))

(define-key pdf-view-mode-map (kbd "<wheel-down>") #'mirage/pdf-view-next-line)
(define-key pdf-view-mode-map (kbd "<wheel-up>")   #'mirage/pdf-view-previous-line)
(define-key pdf-view-mode-map (kbd "C-<wheel-down>") (lambda () (interactive) (mirage/pdf-view-next-line 10)))
(define-key pdf-view-mode-map (kbd "C-<wheel-up>")   (lambda () (interactive) (mirage/pdf-view-previous-line 10)))

#+end_src

*** Fit page

#+begin_src emacs-lisp

(defun mirage/pdf-view-fit-height ()
  (interactive)
  (setq pdf-view-display-size 'fit-page)
  (pdf-view-redisplay t)
  (pdf-view-center-in-window)
  (mirage/pdf-view-jump-to-top))

(defun mirage/pdf-view-fit-width ()
  (interactive)
  (setq pdf-view-display-size 'fit-width)
  (pdf-view-redisplay t)
  (pdf-view-center-in-window))

(define-key pdf-view-mode-map (kbd "<tab>") #'mirage/pdf-view-fit-height)
(define-key pdf-view-mode-map (kbd "C-<tab>") #'mirage/pdf-view-fit-width)

#+end_src

*** Theme change

#+begin_src emacs-lisp

(defun mirage/pdf-refresh-themed-view ()
  (if pdf-view-themed-minor-mode
      (progn (pdf-view-themed-minor-mode -1)
             (pdf-view-themed-minor-mode))))

(add-hook 'mirage/enable-or-load-theme-hook #'mirage/pdf-refresh-themed-view)

#+end_src

** Org Mode
*** Utilities
**** Get
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-get.el
:END:

***** org-get-title

#+begin_src emacs-lisp

(defun mirage/org-get-title (&optional buffer)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (nth 1
	   (assoc "TITLE"
		  (org-element-map (org-element-parse-buffer 'greater-element)
		      '(keyword)
		    #'mirage/get-keyword-key-value))))))

#+end_src

***** org-get-file-title

#+begin_src emacs-lisp

(defun mirage/org-get-file-title (file)
  (with-current-buffer (find-file-noselect file)
       (mirage/org-get-title)))

#+end_src

***** org-get-subtree-region

#+begin_src emacs-lisp

(defun mirage/org-get-subtree-region (&optional element)
  "Retrieve the beginning and end of the current subtree."
  (if (org-element--cache-active-p)
      (let* ((heading (org-element-lineage
                       (or element (org-element-at-point))
                       '(headline) t))
	     (head (org-element-property :begin heading))
	     (next (org-element-property :end   heading)))
	  (if (and heading next)
	      (progn (save-excursion (goto-char head)
				     (beginning-of-line 2)
				     (setq beg (point)))
		     (save-excursion (goto-char next)
				     (beginning-of-line)
				     (setq end (max beg (point))))
		     (list beg end))))))

#+end_src

***** org-get-subtree-content

#+begin_src emacs-lisp

(defun mirage/org-get-subtree-content ()
  "Retrieve the content of the current subtree."
  (setq content (apply #'buffer-substring-no-properties (mirage/org-get-subtree-region))))

#+end_src

**** Queries
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-queries.el
:END:

***** in
****** org-in-src-block-p

#+begin_src emacs-lisp

;; `org-in-src-block-p' gives false positives as of Org Mode 9.5.3. For
;; this reason, determine if cursor in src block with the more reliable
;; `org-babel-where-is-src-block-head'
(defun mirage/org-in-src-block-p (orig-fun &rest args)
  (if args
      (apply orig-fun args)
    (org-babel-where-is-src-block-head)))

(advice-add 'org-in-src-block-p :around #'mirage/org-in-src-block-p)

#+end_src

***** at
****** org-at-ellipsis

#+begin_src emacs-lisp

(defun mirage/org-at-ellipsis (&optional position)
  (or (mirage/org-at-ellipsis-h position) (mirage/org-at-ellipsis-l position)))

#+end_src

****** org-at-ellipsis-l

#+begin_src emacs-lisp

(defun mirage/org-at-ellipsis-l (&optional position)
  (and (mirage/org-relative-line-list-folded) (mirage/at-point 'end-of-visual-line)))

#+end_src 

****** org-at-ellipsis-h

#+begin_src emacs-lisp

(defun mirage/org-at-ellipsis-h (&optional position) 
  (and (mirage/org-relative-line-heading-folded) (mirage/at-point 'end-of-visual-line)))

#+END_src 

****** org-at-keyword

#+begin_src emacs-lisp

(defun mirage/org-at-keyword (&optional number)
  (mirage/relative-line-regex "^#+.*$" number))

#+END_src 

****** org-at-heading

#+begin_src emacs-lisp

(defun mirage/org-at-heading (&optional point)
  (let ((point (or point (point))))
    (save-excursion (goto-char point) (mirage/org-relative-line-heading))))

#+end_src

****** TODO org-at-bol-list

- &option point

#+begin_src emacs-lisp

(defun mirage/org-at-bol-list () 
  (and (mirage/org-relative-line-list) (mirage/at-point 'beginning-of-line-text)))

#+END_src 

****** TODO org-at-bol-heading

- &option point

#+begin_src emacs-lisp

(defun mirage/org-at-bol-heading () 
  (and (mirage/org-relative-line-heading) (mirage/at-point 'mirage/org-goto-heading-bol)))

#+END_src 

****** TODO org-at-eol-heading

- &option point

#+begin_src emacs-lisp

(defun mirage/org-at-eol-heading ()
  (and (mirage/org-relative-line-heading) (eolp) (not (mirage/org-at-ellipsis-h)) (not (mirage/org-relative-line-heading-empty))))

#+end_src

***** after
****** org-after-list-or-indent

#+begin_src emacs-lisp

(defun mirage/org-after-list-or-indent ()
  (or (mirage/org-relative-line-list -1) (mirage/relative-line-indented -1)))

#+end_src

***** line
****** org-relative-line-list

#+begin_src emacs-lisp

(defun mirage/org-relative-line-list (&optional number)
  (mirage/relative-line (lambda () (progn (beginning-of-line-text) (org-at-item-p)))  number))

#+end_src

****** org-relative-line-heading

#+begin_src emacs-lisp

(defun mirage/org-relative-line-heading (&optional number)
  (mirage/relative-line 'org-at-heading-p number))

#+end_src

****** org-relative-line-paragraph

#+begin_src emacs-lisp

(defun mirage/org-relative-line-paragraph (&optional number)
  "Determine whether the current line -or the NUMBER'th line relative to it
is an indented paragraph."
  (let ((number (or number 0)))
    (and (not (mirage/org-relative-line-heading number))
	       (not (mirage/org-relative-line-list    number))
	       (not (org-in-src-block-p))
	       (mirage/relative-line-indented number)
	       (or  (mirage/org-relative-line-list      (- number 1))
		    (mirage/org-relative-line-paragraph (- number 1))))))

#+end_src

****** org-relative-line-list-empty

#+begin_src emacs-lisp

(defun mirage/org-relative-line-list-empty (&optional number)
  (and (mirage/org-relative-line-list)
       (or (mirage/relative-line-regex "^[[:blank:]]*[-+*]\\{1\\}[[:blank:]]+$" number)
	         (mirage/relative-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]+$" number))))

#+end_src

****** org-relative-line-list-folded

#+begin_src emacs-lisp

(defun mirage/org-relative-line-list-folded (&optional number)
  "Returns non-nil if `point-at-eol' of current visual line
is on a folded list item."
  (mirage/relative-line (lambda () (and (org-at-item-p) (invisible-p (point-at-eol)))) number))

#+end_src

****** org-relative-line-heading-empty

#+begin_src emacs-lisp

(defun mirage/org-relative-line-heading-empty (&optional number)
  (mirage/relative-line (lambda () (beginning-of-line-text) (org-point-at-end-of-empty-headline)) number))

#+end_src

****** org-relative-line-heading-folded

#+begin_src emacs-lisp

(defun mirage/org-relative-line-heading-folded (&optional number)
  "Returns non-nil if `point-at-eol' of current visual line
is on a folded heading."
  (mirage/relative-line (lambda () (and (org-at-heading-p) (invisible-p (point-at-eol)))) number))

#+end_src

****** org-relative-line-heading-or-list

#+begin_src emacs-lisp

(defun mirage/org-relative-line-heading-or-list (&optional number)
  (mirage/relative-line 'org-at-heading-or-item-p number))

#+end_src

***** subtree
****** org-subtree-blank

#+begin_src emacs-lisp

(defun mirage/org-subtree-blank ()
  "Return t if the current subtree consists of
a `mirage/region-blank'."
  (interactive)
  (apply 'mirage/region-blank (mirage/org-get-subtree-region)))

#+end_src

****** org-subtree-empty

#+begin_src emacs-lisp

(defun mirage/org-subtree-empty ()
  (interactive)
  (string-equal "" (mirage/org-get-subtree-content)))

#+end_src

****** org-headings-follow

#+begin_src emacs-lisp

(defun mirage/org-headings-follow ()
  (let ((pos (mirage/get-point 'beginning-of-visual-line)))
    (save-excursion (mirage/org-goto-heading-next)
		           (and (not (= pos (point))) (mirage/org-relative-line-heading)))))

#+end_src

****** org-headings-precede

#+begin_src emacs-lisp

(defun mirage/org-headings-precede ()
  (let ((pos (mirage/get-point 'beginning-of-visual-line)))
    (save-excursion (mirage/org-goto-heading-previous)
		          (and (not (= pos (point))) (mirage/org-relative-line-heading)))))

#+end_src

****** org-subtree-blank-up-to-point

#+begin_src emacs-lisp

(defun mirage/org-subtree-blank-up-to-point ()
  (interactive)
  (let ((heading-eol (save-excursion (mirage/org-goto-heading-current) (end-of-line) (point))))
    (mirage/region-blank heading-eol (point))))

#+end_src

***** heading
****** org-heading-first-child

#+begin_src emacs-lisp

(defun mirage/org-heading-first-child ()
  (save-excursion
    (mirage/org-goto-heading-current)
    (let ((pos (mirage/get-point 'beginning-of-visual-line)))
      (org-backward-heading-same-level 1)
      (= pos (mirage/get-point 'beginning-of-visual-line)))))

#+end_src

****** org-heading-has-children

#+begin_src emacs-lisp

(defun mirage/org-heading-has-children ()
  (interactive)
  (save-excursion (org-goto-first-child)))

#+end_src


*** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-ui.el
:END:

**** Theme

#+begin_src emacs-lisp

;; theme reload advice
(defun mirage/org-theme-reload ()
  "Re-set Org Mode UI typesetting after theme changes"
  (save-window-excursion
    (cl-loop for buffer in (mirage/get-visible-buffers)
	     do (select-window (get-buffer-window buffer))
	     if (string-equal major-mode "org-mode")
             do (mirage/org-ui-typeset))))

(add-hook 'mirage/enable-or-load-theme-hook #'mirage/org-theme-reload)

#+end_src

**** Outline
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-outline.el
:END:

- deprecated cl warning
   - find dependency

***** Hide
****** org-hide-previous-subtree

#+begin_src emacs-lisp

(defun mirage/org-hide-previous-subtree ()
  "Cycle previous Org Mode heading."
  (save-excursion (mirage/org-goto-heading-previous)
		  (outline-hide-subtree)))

#+end_src

***** Show
****** org-show

#+begin_src emacs-lisp

(defun mirage/org-show (orig-fun &rest args)
  (if (mirage/org-at-ellipsis)
      (progn (mirage/org-goto-heading-bol) (apply orig-fun args))
    (apply orig-fun args)))

#+end_src

****** org-show-subtree

#+begin_src emacs-lisp

(advice-add 'org-show-subtree :around #'mirage/org-show)

#+end_src

****** org-show-children

#+begin_src emacs-lisp

(advice-add 'org-show-children :around #'mirage/org-show)

#+end_src

****** org-show-minimum

#+begin_src emacs-lisp

(defun mirage/org-show-minimum ()
  (if (or (mirage/org-relative-line-list-folded)
	        (mirage/org-relative-line-heading-folded))
      (progn (if (mirage/org-at-ellipsis)
		       (progn (beginning-of-visual-line) (end-of-line)))
	           (org-show-entry)
	           (if (mirage/org-heading-has-children) (org-show-children)))))

#+end_src

***** TODO Cycle

- bug
   - https://lists.gnu.org/archive/html/emacs-orgmode/2022-05/msg00150.html
   - https://www.reddit.com/r/emacs/comments/ulpdhu/org_mode_command_doesnt_update_a_buffer_if_i_use/

#+begin_src emacs-lisp

(defun mirage/org-cycle (orig-fun &rest args)
  "Conditional `org-cycle'.

Default: `org-cycle'

If cursor lies at `end-of-visual-line' of folded heading or list,
move cursor to `end-of-line' of the current visual line and then
call `org-cycle'.

If cursor lies at a paragraph directly under a list item and not
indented at the level of the previous list item, indent the paragraph."
  (interactive)
  (if (or (mirage/org-relative-line-list-folded) (mirage/org-relative-line-heading-folded))
      (if (= (point) (mirage/get-point 'end-of-visual-line))
	  (progn (beginning-of-visual-line)
		 (end-of-line)
		 (apply orig-fun args))
	(apply orig-fun args))
    (if (and (org-in-src-block-p) (not (mirage/org-at-keyword)))
	      (org-indent-line)
      (apply orig-fun args))))

(advice-add 'org-cycle :around #'mirage/org-cycle)

#+end_src

***** C-Cycle

#+begin_src emacs-lisp

(defun mirage/c-cycle ()
  (interactive)
  (if (and (org-in-src-block-p) (not (invisible-p (point-at-eol))))
      (progn (org-babel-goto-src-block-head)
             (org-fold-hide-block-toggle))
    (org-fold-hide-subtree)))

(define-key org-mode-map (kbd "C-<tab>") #'mirage/c-cycle)

#+end_src

***** TODO Restore

- Not working

- rewrite get-outline-state and set-outline-state
   - org-macs.el

****** Implementation
******* get-outline-state

#+begin_src emacs-lisp

(defun mirage/org-identify-hidden-overlays (overlay &optional use-markers)
  (when (eq (overlay-get overlay 'invisible) 'outline)
    (let ((beg (overlay-start overlay))
          (end (overlay-end overlay)))
      (and beg end (> end beg)
           (if use-markers
               (cons (copy-marker beg)
                     (copy-marker end t))
             (cons beg end))))))

(defun mirage/org-get-outline-state (&optional use-markers)
  "Return a list of the locations of all outline overlays.
These are overlays with the `invisible' property value `outline'.
The return value is a list of cons cells, with start and stop
positions for each overlay.
If USE-MARKERS is set, return the positions as markers."
  (let (beg end)
    (org-with-wide-buffer
     (delq nil
       (mapcar 'mirage/org-identify-hidden-overlays
           (overlays-in (point-min) (point-max)))))))

#+end_src

******* save-outline-state

#+begin_src emacs-lisp

(defun mirage/org-save-outline-state ()
  "Save org outline state in `mirage/org-outline-state'.
It can be recovered afterwards with `mirage/org-recover-outline-state'."
  (setq mirage/org-outline-state (mirage/org-get-outline-state t)))

#+end_src

******* set-outline-state

#+begin_src emacs-lisp

(defvar-local mirage/org-outline-state nil
  "Variable to save the org outline.")
(put 'mirage/org-outline-state 'permanent-local t)

(defun mirage/org-set-outline-state (data)
  "Create visibility overlays for all positions in DATA.
DATA should have been made by `mirage/org-get-outline-state'."
  (org-with-wide-buffer
   (org-show-all)
   (dolist (c data) (org-flag-region (car c) (cdr c) t 'outline))))

#+end_src

******* restore-outline-state

#+begin_src emacs-lisp

(defun mirage/org-restore-outline-state ()
  "Restore Org Mode outline stored in `mirage/org-outline-state'."
  (when mirage/org-outline-state
    (mirage/org-set-outline-state mirage/org-outline-state)
    (setq mirage/org-outline-state nil)))

#+end_src

****** Advice

#+begin_src emacs-lisp

(defun mirage/org-mode (orig-fun &rest args)
  (if (string-equal major-mode "org-mode")
      (progn (mirage/org-save-outline-state)
             (apply orig-fun args)
             (mirage/org-restore-outline-state))
    (apply orig-fun args)))

(advice-add 'org-mode :around #'mirage/org-mode)

#+end_src

**** Typesetting

#+begin_src emacs-lisp

;; UI typesetting
(defun mirage/org-ui-typeset ()
  "Typeset the following Org Mode UI elements:
- title of Org Mode documents
- indent typeface used in `org-indent-mode' and `visual-line-mode'"
  (with-eval-after-load 'org-faces       (set-face-attribute 'org-document-title nil :font typeface-title :weight 'regular :height 200))
  (with-eval-after-load 'org-indent-mode (set-face-attribute 'org-indent         nil :inherit '(org-hide fixed-pitch))))

(add-hook 'org-mode-hook #'mirage/org-ui-typeset)

#+end_src

**** Variable pitch

#+begin_src emacs-lisp

(defface mirage/variable-pitch-marker
  '((nil :inherit fixed-pitch))
  "List marker typeface.")

(defface mirage/variable-pitch-indent
  '((nil :inherit fixed-pitch :invisible t))
  "Indent typeface.")

(defvar mirage/variable-pitch-keywords '(("^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]\\{1\\}" 0 'mirage/variable-pitch-marker)
					 ("^[[:blank:]]*[-+]\\{1\\}[[:blank:]]\\{1\\}"         0 'mirage/variable-pitch-marker)
					 ("^[[:blank:]]+"                                      0 'mirage/variable-pitch-indent))
  "Variable pitch font-lock keywords.")

(font-lock-add-keywords 'org-mode mirage/variable-pitch-keywords 'append)

#+end_src

**** TODO Continuous numbering of equations

#+begin_src emacs-lisp

;; continuous numbering of Org Mode equations
(defun org-renumber-environment (orig-fun &rest args)
  (let ((results '()) 
        (counter -1)
        (numberp))

    (setq results (cl-loop for (begin .  env) in 
                        (org-element-map (org-element-parse-buffer) 'latex-environment
                          (lambda (env)
                            (cons
                             (org-element-property :begin env)
                             (org-element-property :value env))))
                        do
                        (cond
                         ((and (string-match "\\\\begin{equation}" env)
                               (not (string-match "\\\\tag{" env)))
                          (cl-incf counter)
                          (cons begin counter))
                         ((string-match "\\\\begin{align}" env)
                          (prog2
                              (cl-incf counter)
                              (cons begin counter)                          
                            (with-temp-buffer
                              (insert env)
                              (goto-char (point-min))
                              ;; \\ is used for a new line. Each one leads to a number
                              (cl-incf counter (count-matches "\\\\$"))
                              ;; unless there are nonumbers.
                              (goto-char (point-min))
                              (cl-decf counter (count-matches "\\nonumber")))))
                         (t
                          (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))
  
  (apply orig-fun args))

(advice-add 'org-create-formula-image :around #'org-renumber-environment)

#+end_src


*** Editing
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-editing.el
:END:

**** Text
***** Undo

#+begin_src emacs-lisp

(defun mirage/org-undo ()
  (interactive)
  (if (org-babel-where-is-src-block-head)
      (let ((beg (point)))
	         (cond ((eq last-command 'mirage/org-return)    (undo 2))
                       ((eq last-command 'mirage/smart-comment) (undo 1))
	               (t                                       (undo 1)))
           (if (org-babel-where-is-src-block-head)
	             (save-excursion (goto-char (org-babel-where-is-src-block-head))
				     (next-line)
				     (setq hang (point))))
		 (if (= hang (point))
		     (progn (goto-char beg)
			    (beginning-of-line-text))))
    (undo 1)))

(define-key org-mode-map (kbd "C-/") #'mirage/org-undo)

#+end_src

***** Insert
****** Items
******* org-insert-item-respect-content

#+begin_src emacs-lisp

(defun mirage/org-insert-item-respect-content ()
  (interactive)
  (let ((struct (org-list-struct))
	    (unfold (if (mirage/org-relative-line-list-folded) nil (point-marker))))
    (org-list-set-item-visibility (point-at-bol) struct 'folded)
    (save-excursion
      (beginning-of-visual-line)
      (kill-ring-save (point) (mirage/get-point 'beginning-of-line-text)))
    (end-of-visual-line)
    (org-return)
    (yank)
    (if unfold (save-excursion (goto-char unfold) (org-list-set-item-visibility (point-at-bol) struct 'subtree)))))

#+end_src

****** Headings
******* Margins
******** org-heading-margin-post

#+begin_src emacs-lisp

(defun mirage/org-heading-margin-post ()
  "Return margin between current heading and next."
  (if (org-current-level)
      (let ((pos (mirage/get-point 'mirage/org-goto-heading-bol))
	    (end-of-subtree (mirage/get-point 'mirage/org-goto-subtree-end))
	    (next-heading   (mirage/get-point 'mirage/org-goto-heading-next)))
	(if (not (and (= pos end-of-subtree) (mirage/org-relative-line-heading)))
	    (buffer-substring-no-properties end-of-subtree next-heading)
	  ""))
    (if (mirage/org-headings-follow)
	       (buffer-substring-no-properties (point) (mirage/get-point 'mirage/org-goto-heading-next))
      "")))

#+end_src

******** org-heading-margin-delete-post

#+begin_src emacs-lisp

(defun mirage/org-heading-margin-delete-post ()
  "Delete newline after new headings created by
`respect-content' heading commands."
  (if (mirage/org-subtree-blank)
      (apply 'delete-region (mirage/org-get-subtree-region))))

#+end_src

******** org-heading-margin-insert-previous

#+begin_src emacs-lisp

(defun mirage/org-heading-margin-insert-previous ()
  "If the previous subtree is not empty,
insert a margin of 1 empty line."
  (let ((insert-margin (save-excursion (if (mirage/org-heading-first-child)
					          (mirage/org-goto-heading-previous)
					        (org-backward-heading-same-level 1))
				              (not (mirage/org-subtree-blank)))))
    (if insert-margin
      (progn (beginning-of-visual-line)
	            (org-return)
		    (beginning-of-line-text)))))

#+end_src

******* org-insert-heading

#+begin_src emacs-lisp

(defun mirage/org-insert-heading (command &optional margin)
  "Primitive for custom heading functions.

If cursor if at an Org Mode heading's
ellipsis, go to the `end-of-line' of the
heading's visual line.

If cursor lies on an Org Mode heading,
`mirage/org-show-minimum'.

If cursor is outside top level heading,
insert heading at point, without removing
any of the previous space.

If the previous subtree is not empty,
insert a margin of 1 empty line.
This is because Org Mode heading insertion
commands will automatically remove all [[:space:]]
until first preceding non-empty line.

If MARGIN is t:
- insert margin between content under parent heading and new one"
  (interactive)
  (if (mirage/org-at-ellipsis-h)         (progn (beginning-of-visual-line) (end-of-line)))
  (if (mirage/org-relative-line-heading) (mirage/org-show-minimum))
  ;; Insert heading
  (cond ((not (org-current-level)) (insert "* "))
        (t                         (funcall command)))
  ;; Insert margin
  (if margin (mirage/org-heading-margin-insert-previous))
  ;; Hide previous subtree
  (if (save-excursion (mirage/org-goto-heading-previous)
		      (mirage/org-relative-line-heading-folded))
      (mirage/org-hide-previous-subtree)))

#+end_src

******* org-insert-subheading

#+begin_src emacs-lisp

(defun mirage/org-insert-subheading (orig-fun &optional arg)
  "Make `org-insert-subheading' ARG optional."
  (interactive)
  (let ((arg (or arg 0)))
    (funcall orig-fun arg)))

(advice-add 'org-insert-subheading :around #'mirage/org-insert-subheading)

#+end_src

******* org-insert-heading-at-point

#+begin_src emacs-lisp

(defun mirage/org-insert-heading-at-point ()
  (interactive)
  (mirage/org-insert-heading 'org-insert-heading (not (mirage/org-subtree-blank-up-to-point))))

#+end_src

******* org-insert-subheading-at-point

#+begin_src emacs-lisp

(defun mirage/org-insert-subheading-at-point ()
  (interactive)
  (mirage/org-insert-heading 'org-insert-subheading (not (mirage/org-subtree-blank-up-to-point))))

#+end_src

******* org-insert-heading-after-subtree

#+begin_src emacs-lisp

(defun mirage/org-insert-heading-after-subtree ()
  "Insert heading after current subtree. As
`org-insert-heading-respect-content' does not
behave well with folded Org Mode headings, if
the previous heading is folded:
1. Unfold the heading
2. Create the new heading after its subtree
3. Fold it back"
  (let ((margin-post        (mirage/count-substrings "\n" (mirage/org-heading-margin-post)))
	(prev-same-level    (mirage/get-point 'beginning-of-visual-line))
	(prev-lower-level   (mirage/get-point 'mirage/org-goto-child-last))
	(folded-same-level  (mirage/org-relative-line-heading-folded))
	(folded-lower-level (save-excursion (mirage/org-goto-child-last)
                                            (mirage/org-relative-line-heading-folded))))

    ;; Go to current heading
    (mirage/org-goto-heading-current)

    ;; Unfold if necessary
    (if folded-same-level  (save-excursion (org-show-subtree)))
    (if folded-lower-level (save-excursion (mirage/org-goto-subtree-end) (org-show-subtree)))
    
    ;; Insert heading
    (cond ((not (org-current-level)) (insert "* "))
	        (t                         (progn (mirage/org-goto-heading-current) (org-insert-heading-respect-content))))
    (mirage/org-heading-margin-delete-post)

    ;; Insert margin with previous heading
    (mirage/org-heading-margin-insert-previous)
    
    ;; Fold back if necessary
    (if folded-same-level  (save-excursion (goto-char prev-same-level)  (outline-hide-subtree)))
    (if folded-lower-level (save-excursion (goto-char prev-lower-level) (outline-hide-subtree)))

    ;; Recover margin with following heading
    (if (> margin-post 1) (save-excursion (insert "\n")))))
  
#+end_src

******* org-insert-subheading-after-subtree

#+begin_src emacs-lisp

(defun mirage/org-insert-subheading-after-subtree ()
  "`org-insert-subheading' respecting content."
  (interactive)
  (mirage/org-show-minimum)
  (if (mirage/org-heading-has-children)
      (progn (mirage/org-goto-child-last)
	           (mirage/org-insert-heading-after-subtree))
    (progn (mirage/org-insert-heading-after-subtree)
	         (org-do-demote))))

#+end_src

****** Edition at ellipses

#+begin_src emacs-lisp

(defvar mirage/org-functions-at-ellipsis '(org-self-insert-command
					   mirage/kill-ring-mouse)
  "Functions whose behavior at Org Mode ellipses
will be advised by `mirage/org-edit-at-ellipsis'")

(defun mirage/org-edit-at-ellipsis (orig-fun &rest args)
  "Execute commands invoked at an Org Mode heading's
ellipsis in the first line under the heading."
  (if (mirage/org-at-ellipsis-h)
      (progn (beginning-of-visual-line)
	     (mirage/org-show-minimum)
	     (end-of-line)
	     (org-return)
	     (apply orig-fun args))
    (apply orig-fun args)))

(dolist (function mirage/org-functions-at-ellipsis)
  (advice-add function :around #'mirage/org-edit-at-ellipsis))

#+end_src

***** Return
****** return

- References
   - https://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/

#+begin_src emacs-lisp

;; org-return
(defun mirage/org-return ()
  "Conditional `org-return'."
  (interactive)
  (cond ((mirage/org-relative-line-list-empty)          (progn (mirage/delete-line) (org-return)))
	     ((mirage/org-at-bol-list)                       (progn (beginning-of-visual-line) (org-return) (beginning-of-line-text)))
	     ((mirage/org-at-ellipsis-l)                     (mirage/org-insert-item-respect-content))
	     ((mirage/org-relative-line-paragraph)           (org-insert-item))
	     ((mirage/org-relative-line-list)                (org-meta-return))
	     ((and (mirage/org-after-list-or-indent) (bolp)) (org-return))
	     ((mirage/org-at-bol-heading)                    (save-excursion (beginning-of-visual-line) (org-return t)))
	     ((mirage/org-at-eol-heading)                    (progn (newline 2) (if (mirage/org-subtree-blank) (progn (newline) (previous-line)))))
	     ((mirage/org-at-ellipsis-h)                     (org-return))
	     (t                                              (org-return t))))

(define-key org-mode-map (kbd "<return>") #'mirage/org-return)

#+end_src

****** TODO C-return

- at ellipsis -> doesn't work

- on non-empty line
   - insert heading at line

- list paragraphs
   - mirage/org-toggle-paragraph
      - keep cursor in place

- bugs
   - if at empty heading or heading separated by more than 1 empty line from next
      - star is inserted in line of next heading
         - "* " is inserted in line of next heading
   - cycle previous heading to remove spurious separation line

- if list not empty -> move contents to new item
- if after list
   - create list item from current line
- if before list
   - create list item at top of list

- if at indented paragraph in list
   - turn paragraph into list item
- if at non-empty line, turn entire non-empty line into either header or list item
   - if at middle of word inside list
      - new indented list item, break word and place second part in new item

#+begin_src emacs-lisp

;; org-meta-return
(defun mirage/org-control-return ()
  (interactive)
  (cond ((mirage/org-relative-line-list-empty) (progn (org-meta-return) (next-line) (end-of-line)))
	    ((mirage/org-relative-line-heading)    (mirage/org-insert-heading-after-subtree))
	    ((mirage/org-relative-line-list)       (progn (end-of-line) (org-meta-return)))
	    ((mirage/org-relative-line-paragraph)  (mirage/org-paragraph-toggle))
	    (t                                     (mirage/org-insert-heading-after-subtree))))

(define-key org-mode-map (kbd "C-<return>") #'mirage/org-control-return)

#+end_src

****** M-return

#+begin_src emacs-lisp

(defun mirage/org-meta-return ()
  (interactive)
  (mirage/org-insert-subheading-after-subtree))

(define-key org-mode-map (kbd "M-<return>") #'mirage/org-meta-return)

#+end_src

****** TODO S-return

- heading with keywords
   - skip keywords

#+begin_src emacs-lisp

(defun mirage/org-super-return ()
  (interactive)
  (cond ((or (mirage/org-relative-line-list)
	     (mirage/org-relative-line-paragraph)) (org-return t))
	(t                                         (mirage/org-insert-subheading-at-point))))

(define-key org-mode-map (kbd "S-<return>") #'mirage/org-super-return)

#+end_src

****** MS-return

#+begin_src emacs-lisp
 
(define-key org-mode-map (kbd "M-S-<return>") #'mirage/org-insert-heading-at-point)

#+end_src

****** CS-return

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-S-<return>") 'org-insert-todo-heading)

#+end_src

****** CM-return

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-M-<return>") 'org-insert-todo-subheading)

#+end_src

***** Delete
****** Hungry

#+begin_src emacs-lisp

(defun mirage/org-delete-hungry ()
  "If the region starts at the beginning of an 
indented line and the cursor lies on an Org Mode
src block, delete the region and its indent plus 
one character."
  (interactive)
  (mirage/@delete-hungry (org-in-src-block-p)))

#+end_src

****** TODO Forward

- next line = empty list item -> delete next line

#+begin_src emacs-lisp

(defun mirage/org-nimble-delete-forward ()
  "Org Mode complement to `mirage/nimble-delete-forward'."
  (interactive)
  (cond ((and (mirage/org-at-ellipsis-h)
	           (mirage/org-relative-line-heading 1))  (progn (beginning-of-visual-line 2)
								 (beginning-of-line-text)
								 (delete-forward-char 1)))
	      (t (mirage/nimble-delete-forward))))

(define-key org-mode-map (kbd "<delete>") #'mirage/org-nimble-delete-forward)

#+end_src

****** TODO Backward

- bullets with extra space between marker and text
   -    no action

- if at beginning of empty heading and a heading lies below
   - bring next heading to level of current one
      - delete newline + stars of the next heading
- delete empty heading
   - go to previous line
   - delete newline
      - maybe cycle previous

#+begin_src emacs-lisp

(defun mirage/org-nimble-delete-backward ()
  "Org Mode complement to `mirage/nimble-delete-backward'."
  (interactive)
  (cond ((and (region-active-p)
	           (not (mirage/region-blank)))                 (mirage/org-delete-hungry))
	     ((or  (mirage/org-at-ellipsis-h)
		   (mirage/org-at-ellipsis-l))                  (progn (beginning-of-visual-line) (end-of-line) (delete-backward-char 1)))
	     ((and (or (mirage/org-relative-line-heading-empty)
		       (mirage/org-relative-line-list-empty))
		   (org-current-level))                         (delete-region (point) (mirage/get-point 'end-of-line 0)))
	     ((or  (mirage/org-relative-line-heading-empty)
		   (mirage/org-relative-line-list-empty))       (delete-region (point) (mirage/get-point 'beginning-of-visual-line)))
	     ((mirage/org-at-bol-list)                          (mirage/org-toggle-item))
        (t                                                 (mirage/nimble-delete-backward))))

(define-key org-mode-map (kbd "<backspace>") #'mirage/org-nimble-delete-backward)

#+end_src

***** Toggle
****** org-toggle-item

#+begin_src emacs-lisp

(defun mirage/org-toggle-item ()
  (interactive)
  (let ((toggle-off (mirage/org-relative-line-list))
	     (indent     (+ 1 org-list-indent-offset))
	     (marker     (point)))
    (beginning-of-line-text)
    (delete-backward-char indent)
    (if toggle-off
	     (insert (make-string indent ?\s))
      (org-toggle-item 0))
    (goto-char marker)))

#+end_src

**** Structure
***** TODO indent-region

- use markers
   - https://www.gnu.org/software/emacs/manual/html_node/mirage/Overview-of-Markers.html
  
- regions spanning headings
   - nested headings
      - indent of 1 for every heading from top level in region
- bad interaction with wrapped lines

#+begin_src emacs-lisp

(defun mirage/org-indent-region (command &rest args)
  "Indent Org Mode region.

If the region spans Org Mode headings or items:
1. Extend region by pushing `region-beginning' to its
`beginning-of-visual-line'
2. Execute COMMAND
3. Restore the region to its previous limits, shifting
its limits to match shifts in the position of the
text it spans, such as when indenting with `org-metaright'
or outdenting with `org-metaleft'."
  (if (or (mirage/org-relative-line-heading) (mirage/org-relative-line-list))
      (let ((beg (region-beginning))
	         (end (region-end))
		 (pos (point)))
	
	        ;; Determine mark
	        (setq mark (if (= pos beg) end beg))
		;; Count lines in region
		(setq lines (count-screen-lines beg end))

		;; Get initial cursor position wrt bol
		(setq relative-pos-0 (- pos (mirage/get-point 'beginning-of-line)))
		;; Execute command
		(save-excursion (goto-char beg)
				(push-mark (mirage/get-point 'beginning-of-line))
		 		(goto-char end)
				(end-of-visual-line)
				(apply command args))
		;; Get aftermath cursor position
		(setq pos-1 (point))
		;; Calculate cursor displacement
		(setq disp (- pos-1 pos))
		
           ;; Get aftermath cursor position wrt bol
		(setq relative-pos-1 (- pos-1 (mirage/get-point 'beginning-of-line)))
		;; Calculate cursor displacement wrt bol
		(setq relative-disp (- relative-pos-1 relative-pos-0))

		;; Calculate mark shift
		(cond
		 ((mirage/org-at-heading beg)  (setq shift disp))
		 ((= mark beg)                 (setq shift relative-disp))
		 ((= mark end)                 (setq shift (* relative-disp lines))))

		;; Push mark
		(push-mark (+ mark shift)))
    (apply command args)))

#+end_src

**** Preferences
***** Keep text selection after executing commands

#+begin_src emacs-lisp

(defun mirage/with-mark-active (&rest args)
  "Keep mark active after command. To be used as advice AFTER any
function that sets `deactivate-mark' to t."
  (setq deactivate-mark nil))

(advice-add 'org-metaright      :after #'mirage/with-mark-active)
(advice-add 'org-metaleft       :after #'mirage/with-mark-active)
(advice-add 'org-metaup         :after #'mirage/with-mark-active)
(advice-add 'org-metadown       :after #'mirage/with-mark-active)

(advice-add 'org-shiftmetaright :after #'mirage/with-mark-active)
(advice-add 'org-shiftmetaleft  :after #'mirage/with-mark-active)
(advice-add 'org-shiftmetaup    :after #'mirage/with-mark-active)
(advice-add 'org-shift-metadown :after #'mirage/with-mark-active)

#+end_src

***** Do not insert newline before Org Mode headigs

#+begin_src emacs-lisp

;; Do not insert newline before Org Mode headings
(setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))

#+end_src


*** Navigation
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-navigation.el
:END:

**** Line
***** org-end

#+begin_src emacs-lisp

(defun mirage/org-end ()
  "Conditional end in Org Mode.

Default: `mirage/end'

If `org-at-table-p', go to `org-table-end-of-field'."
  (cond ((and (region-active-p) (mirage/org-relative-line-heading-folded)) (end-of-line))
        ((org-at-table-p)                                                  (org-table-end-of-field 1))
	(t                                                                 (end-of-visual-line))))

(defvar mirage/org-double-end-timeout 0.4)

(defun mirage/org-double-end ()
  "Dynamic homing command with a timeout of `mirage/org-double-end-timeout' seconds.
- Single press: `mirage/org-home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'mirage/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) mirage/org-double-end-timeout)
	         (not (org-at-table-p)))
        (progn (beginning-of-visual-line) (end-of-line))
      (mirage/org-end)))
  (put this-command 'mirage/last-call-time (current-time)))

(define-key org-mode-map (kbd "<end>") #'mirage/org-double-end)

#+end_src

***** TODO org-home

- home in invisible tags -> to beginning of tag text

#+begin_src emacs-lisp

(defun mirage/org-home ()
     "Conditional homing in Org Mode.

Default: `mirage/home'

If a multi-visual-line region is active and the cursor lies on a heading or
list item, home to `beginning-of-visual-line'.

If a region is active the cursor lies `mirage/org-at-ellipsis-h', home to
`beginning-of-visual-line'.

If the cursor lies `mirage/org-at-ellipsis-h' (no active region), home to
the `beginning-of-line-text' of the heading's visual line.

If the cursor lies on at heading or list, home to `beginning-of-line-text'.

If the cursor lies in a source code block, and the current line is a wrapped
visual line, home to `beginning-of-visual-line'.

If the cursor lies in a source code block, home `back-to-indentation'.

If `org-at-table-p', home to `org-table-beginning-of-field'."
   (interactive)
   (cond ((and (mirage/region-multiline-visual) (mirage/org-relative-line-heading-or-list))  (beginning-of-visual-line))
         ((and (region-active-p) (mirage/org-at-ellipsis-h))                                 (beginning-of-visual-line))
         ((mirage/org-at-ellipsis-h)                                                         (mirage/org-goto-heading-bol))
	     ((mirage/org-at-ellipsis-l)                                                         (mirage/org-goto-heading-bol))
	     ((mirage/relative-line-wrapped)                                                     (beginning-of-visual-line))
         ((mirage/org-relative-line-heading-or-list)                                         (beginning-of-line-text))
         ((org-in-src-block-p)                                                               (back-to-indentation))
	     ((org-at-table-p)                                                                   (org-table-beginning-of-field 1))
         (t                                                                                  (mirage/home))))

(defvar mirage/org-double-home-timeout 0.4)

(defun mirage/org-double-home ()
  "Dynamic homing command with a timeout of `mirage/org-double-home-timeout' seconds.
- Single press: `mirage/org-home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'mirage/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) mirage/org-double-home-timeout)
	         (not (org-at-table-p)))
	    (beginning-of-line)
      (mirage/org-home)))
  (put this-command 'mirage/last-call-time (current-time)))

(define-key org-mode-map (kbd "<home>") #'mirage/org-double-home)

#+end_src

**** Subtree
***** org-goto-child-last

#+begin_src emacs-lisp

(defun mirage/org-goto-child-last ()
  (if (org-current-level)
      (progn (mirage/org-goto-subtree-end)
	     (mirage/org-goto-heading-current))))

#+end_src

***** org-goto-subtree-end

#+begin_src emacs-lisp

(defun mirage/org-goto-subtree-end ()
  (mirage/org-goto-heading-current)
  (org-end-of-subtree)
  (if (mirage/org-relative-line-heading-folded) (end-of-visual-line)))

#+end_src

**** Heading
***** org-goto-heading-bol

#+begin_src emacs-lisp

(defun mirage/org-goto-heading-bol ()
  (beginning-of-visual-line)
  (beginning-of-line-text))

#+end_src

***** org-goto-heading-next

#+begin_src emacs-lisp

(defun mirage/org-goto-heading-next ()
  (mirage/org-goto-heading-current)
  (let ((pos (mirage/get-point 'beginning-of-visual-line)))
       (org-forward-heading-same-level 1)
       (if (= pos (point))
	   (progn (mirage/org-goto-heading-parent)
		  (org-forward-heading-same-level 1)))))

#+end_src

***** org-goto-heading-parent

#+begin_src emacs-lisp

(defun mirage/org-goto-heading-parent ()
  (let ((current (mirage/get-point 'beginning-of-visual-line)))
    (if (and (org-current-level)
	        (not (= 1 (org-current-level)))
		(= current (mirage/get-point 'beginning-of-visual-line)))
	   (outline-up-heading 1))))

#+end_src

***** org-goto-heading-current

#+begin_src emacs-lisp

(defun mirage/org-goto-heading-current ()
  (if (org-current-level) (outline-back-to-heading)))

#+end_src

***** org-goto-heading-previous

#+begin_src emacs-lisp

(defun mirage/org-goto-heading-previous ()
  (mirage/org-goto-heading-current)
  (let ((current (mirage/get-point 'beginning-of-visual-line)))
    ;; go to previous same-level heading
    (org-backward-heading-same-level 1)
    ;; if there was no previous same-level heading, go to parent if not at top
    (if (= (point) current)
	(mirage/org-goto-heading-parent)
      ;; else, attempt going to last subheading of previous same-level heading
      (mirage/org-goto-child-last))))

#+end_src

**** Custom link types

Macros to make the creation of custom link types a breeze.

***** Link to items in a specific directory

#+begin_src emacs-lisp

(defmacro @mirage/org-dir-link-complete (name dir)
  `(defun ,(intern (concat "org-" name "-link-complete")) ()
     "Create an org-link target string to a file in org-`name'-link-complete."
     (concat ,name ":" (file-relative-name (read-file-name "File: " ,dir) ,dir))))

(defmacro @mirage/org-dir-link-follow (name dir)
  `(defun ,(intern (concat "org-" name "-link-follow")) (link)
     "Follow an org-link to a file in org-`name'-link-follow."
     (find-file (expand-file-name link ,dir))))

(defmacro @mirage/org-dir-link (name dir)
  `(progn (@mirage/org-dir-link-complete ,name ,dir)
          (@mirage/org-dir-link-follow   ,name ,dir)
          (org-link-set-parameters ,name
                                   :complete ',(intern (concat "org-" name "-link-complete"))
                                   :follow   ',(intern (concat "org-" name "-link-follow")))))

#+end_src


*** Applications
**** Agenda
***** org-agenda
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-agenda.el
:END:
****** UI
******* org-agenda-format-date

#+begin_src emacs-lisp

(require 'cal-iso)

(defun mirage/org-agenda-format-date-aligned (date)
  "Format a DATE string for display in the daily/weekly agenda.
This function makes sure that dates are aligned for easy reading."
  (let* ((dayname (calendar-day-name date))
	 (day (cadr date))
	 (day-of-week (calendar-day-of-week date))
	 (month (car date))
	 (monthname (calendar-month-name month))
	 (year (nth 2 date))
         ;; extra information
	 (iso-week (org-days-to-iso-week
		    (calendar-absolute-from-gregorian date)))
	 (weekyear (cond ((and (= month 1) (>= iso-week 52))
			  (1- year))
			 ((and (= month 12) (<= iso-week 1))
			  (1+ year))
			 (t year)))
	 (weekstring (if (= day-of-week 1)
			 (format " W%02d" iso-week)
		       ""))
         ;; label
         (label-length 26)
         (label (format "%-9s %2d %-9s"
                        dayname day monthname))
         ;; margin fill
         (fill (make-string (/ (- label-length (string-width label)) 2) 32))
         ;; separators
         (sep-l (concat ">>" fill))
         (sep-r (concat fill "<<"))
         ;; highlights
         (highlight-l (make-string (- (/ (window-width) 2)
                                      (/ (string-width label) 2)
                                      (string-width sep-l)) 9472))
         (highlight-r (make-string (- (/ (window-width) 2)
                                      (/ (string-width label) 2)
                                      (string-width sep-r)) 9472)))
    (concat highlight-l sep-l label sep-r highlight-r)))

(setq org-agenda-format-date #'mirage/org-agenda-format-date-aligned)

#+end_src

****** Editing

#+begin_src emacs-lisp

;; Mark items as done
(defun mirage/org-agenda-todo-done ()
  (interactive)
  (org-agenda-todo 'done))

(define-key org-agenda-mode-map (kbd "d") #'mirage/org-agenda-todo-done)

#+end_src

****** Navigation
******* TODO Visit

- desired behavior
   - restore outline after recentering
   - org-recenter -> unfold -> move away -> fold back
      - recenter -> save outline -> unfold item
      - arrows -> restore outline
- currently
   - org-recenter -> all todo items unfolded

#+begin_src emacs-lisp :tangle no

(defun mirage/org-agenda-recenter (orig-fun &rest args)
  (interactive "P")
  (let ((last-called (get this-command 'mirage/last-call-time)))
    (if (eq last-command this-command)
        (progn (mirage/org-restore-outline-state)
	       (org-agenda-recenter arg))
      (progn (mirage/org-save-outline-state)
	     (org-agenda-recenter arg))))
  (put this-command 'mirage/last-call-time (current-time)))

(advice-add 'org-agenda-recenter :around #'mirage/org-agenda-recenter)

#+end_src

**** Programming
***** org-babel
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/mirage-org-babel.el
:END:
****** TODO Result formatting

Modify ~org-babel-insert-result~ such that a list stores all result insertion formats,
allowing users to easily add custom result insertion formats.

- [[https://www.reddit.com/r/emacs/comments/z3lz0d/orgbabel_custom_result_formatting_automatic/][Discussion on Reddit]]

******* Default formats

#+begin_src emacs-lisp

(defvar mirage/org-babel-result-wrap-formats
  '(((assq :wrap (nth 2 info))
     (let* ((full (or (cdr (assq :wrap (nth 2 info))) "results"))
	    (split (split-string full))
	    (type (car split))
	   (opening-line (concat "#+begin_" full))
	   (closing-line (concat "#+end_" type)))
       (cond
        ;; Escape contents from "export" wrap.  Wrap
        ;; inline results within an export snippet with
        ;; appropriate value.
        ((eq t (compare-strings type nil nil "export" nil nil t))
	 (let ((backend (pcase split
			  (`(,_) "none")
			  (`(,_ ,b . ,_) b))))
	   (funcall wrap
		    opening-line closing-line
		    nil nil
		    (format "{{{results(@@%s:"
			    backend) "@@)}}}")))
        ;; Escape contents from "example" wrap.  Mark
        ;; inline results as verbatim.
	((eq t (compare-strings type nil nil "example" nil nil t))
	 (funcall wrap
		  opening-line closing-line
		  nil nil
		  "{{{results(=" "=)}}}"))
	;; Escape contents from "src" wrap.  Mark
	;; inline results as inline source code.
	((eq t (compare-strings type nil nil "src" nil nil t))
	 (let ((inline-open
		(pcase split
		  (`(,_)
		   "{{{results(src_none{")
		  (`(,_ ,language)
		   (format "{{{results(src_%s{" language))
		  (`(,_ ,language . ,rest)
		   (let ((r (mapconcat #'identity rest " ")))
		     (format "{{{results(src_%s[%s]{"
			     language r))))))
	   (funcall wrap
		    opening-line closing-line
		    nil nil
		    inline-open "})}}}")))
	;; Do not escape contents in non-verbatim
	;; blocks.  Return plain inline results.
	(t
	 (funcall wrap
		  opening-line closing-line
		  t nil
		  "{{{results(" ")}}}")))))
    ((member "html" result-params)
     (funcall wrap "#+begin_export html" "#+end_export" nil nil
	      "{{{results(@@html:" "@@)}}}"))
    ((member "latex" result-params)
     (funcall wrap "#+begin_export latex" "#+end_export" nil nil
	      "{{{results(@@latex:" "@@)}}}"))
    ((member "org" result-params)
     (goto-char beg) (when (org-at-table-p) (org-cycle))
     (funcall wrap "#+begin_src org" "#+end_src" nil nil
	      "{{{results(src_org{" "})}}}"))
    ((member "code" result-params)
     (let ((lang (or lang "none")))
       (funcall wrap (format "#+begin_src %s%s" lang results-switches)
		"#+end_src" nil nil
		(format "{{{results(src_%s[%s]{" lang results-switches)
		"})}}}")))
    ((member "raw" result-params)
     (goto-char beg) (when (org-at-table-p) (org-cycle)))
    ((or (member "drawer" result-params)
	 ;; Stay backward compatible with <7.9.2
	 (member "wrap" result-params))
     (goto-char beg) (when (org-at-table-p) (org-cycle))
     (funcall wrap ":results:" ":end:" 'no-escape nil
	      "{{{results(" ")}}}"))
    ((and inline (member "file" result-params))
     (funcall wrap nil nil nil nil "{{{results(" ")}}}"))
    ((and (not (funcall tabulablep result))
	  (not (member "file" result-params)))
     (let ((org-babel-inline-result-wrap
	    ;; Hard code {{{results(...)}}} on top of
	    ;; customization.
	    (format "{{{results(%s)}}}"
		    org-babel-inline-result-wrap)))
       (org-babel-examplify-region
	beg end results-switches inline)))))

#+end_src

******* Custom formats
******** LaTeX equations

Display results inside of a LaTeX ~equation~ environment, and automatically preview it with ~org-latex-preview~.

#+begin_src emacs-lisp

(add-to-list 'mirage/org-babel-result-wrap-formats
             '((member "latex-eq" result-params)
               (progn (funcall wrap "\\begin{equation}" "\\end{equation}" nil nil
	                       "{{{results(@@latex:" "@@)}}}"))
                      (org-latex-preview)))

#+end_src

******* Patch

#+begin_src emacs-lisp

(el-patch-feature org-babel)
(el-patch-defun org-babel-insert-result (result &optional result-params info hash lang exec-time)
  "Insert RESULT into the current buffer.

By default RESULT is inserted after the end of the current source
block.  The RESULT of an inline source block usually will be
wrapped inside a `results' macro and placed on the same line as
the inline source block.  The macro is stripped upon export.
Multiline and non-scalar RESULTS from inline source blocks are
not allowed.  When EXEC-TIME is provided it may be included in a
generated message.  With optional argument RESULT-PARAMS controls
insertion of results in the Org mode file.  RESULT-PARAMS can
take the following values:

replace - (default option) insert results after the source block
          or inline source block replacing any previously
          inserted results.

silent -- no results are inserted into the Org buffer but
          the results are echoed to the minibuffer and are
          ingested by Emacs (a potentially time consuming
          process).

none ---- no results are inserted into the Org buffer nor
          echoed to the minibuffer. they are not processed into
          Emacs-lisp objects at all.

file ---- the results are interpreted as a file path, and are
          inserted into the buffer using the Org file syntax.

list ---- the results are interpreted as an Org list.

raw ----- results are added directly to the Org file.  This is
          a good option if you code block will output Org
          formatted text.

drawer -- results are added directly to the Org file as with
          \"raw\", but are wrapped in a RESULTS drawer or results
          macro, allowing them to later be replaced or removed
          automatically.

org ----- results are added inside of a \"src_org{}\" or \"#+BEGIN_SRC
          org\" block depending on whether the current source block is
          inline or not.  They are not comma-escaped when inserted,
          but Org syntax here will be discarded when exporting the
          file.

html ---- results are added inside of a #+BEGIN_EXPORT HTML block
          or html export snippet depending on whether the current
          source block is inline or not.  This is a good option
          if your code block will output html formatted text.

latex --- results are added inside of a #+BEGIN_EXPORT LATEX
          block or latex export snippet depending on whether the
          current source block is inline or not.  This is a good
          option if your code block will output latex formatted
          text.

code ---- the results are extracted in the syntax of the source
          code of the language being evaluated and are added
          inside of a source block with the source-code language
          set appropriately.  Also, source block inlining is
          preserved in this case.  Note this relies on the
          optional LANG argument.

list ---- the results are rendered as a list.  This option not
          allowed for inline source blocks.

table --- the results are rendered as a table.  This option not
          allowed for inline source blocks.

INFO may provide the values of these header arguments (in the
`header-arguments-alist' see the docstring for
`org-babel-get-src-block-info'):

:file --- the name of the file to which output should be written.

:wrap --- the effect is similar to `latex' in RESULT-PARAMS but
          using the argument supplied to specify the export block
          or snippet type."
  (cond ((stringp result)
	 (setq result (org-no-properties result))
	 (when (member "file" result-params)
	   (setq result
                 (org-babel-result-to-file
		  result
		  (org-babel--file-desc (nth 2 info) result)
                  'attachment))))
	((listp result))
	(t (setq result (format "%S" result))))

  (if (and result-params (member "silent" result-params))
      (progn (message (replace-regexp-in-string "%" "%%" (format "%S" result)))
	     result)
    (let ((inline (let ((context (org-element-context)))
		    (and (memq (org-element-type context)
			       '(inline-babel-call inline-src-block))
			 context))))
      (when inline
	(let ((warning
	       (or (and (member "table" result-params) "`:results table'")
		   (and result (listp result) "list result")
		   (and result (string-match-p "\n." result) "multiline result")
		   (and (member "list" result-params) "`:results list'"))))
	  (when warning
	    (user-error "Inline error: %s cannot be used" warning))))
      (save-excursion
	(let* ((visible-beg (point-min-marker))
	       (visible-end (copy-marker (point-max) t))
	       (inline (let ((context (org-element-context)))
			 (and (memq (org-element-type context)
				    '(inline-babel-call inline-src-block))
			      context)))
	       (existing-result (org-babel-where-is-src-block-result t nil hash))
	       (results-switches (cdr (assq :results_switches (nth 2 info))))
	       ;; When results exist outside of the current visible
	       ;; region of the buffer, be sure to widen buffer to
	       ;; update them.
	       (outside-scope (and existing-result
				   (buffer-narrowed-p)
				   (or (> visible-beg existing-result)
				       (<= visible-end existing-result))))
	       beg end indent)
	  ;; Ensure non-inline results end in a newline.
	  (when (and (org-string-nw-p result)
		     (not inline)
		     (not (string-equal (substring result -1) "\n")))
	    (setq result (concat result "\n")))
	  (unwind-protect
	      (progn
		(when outside-scope (widen))
		(if existing-result (goto-char existing-result)
		  (goto-char (org-element-property :end inline))
		  (skip-chars-backward " \t"))
		(unless inline
		  (setq indent (current-indentation))
		  (forward-line 1))
		(setq beg (point))
		(cond
		 (inline
		   ;; Make sure new results are separated from the
		   ;; source code by one space.
		   (unless existing-result
		     (insert " ")
		     (setq beg (point))))
		 ((member "replace" result-params)
		  (delete-region (point) (org-babel-result-end)))
		 ((member "append" result-params)
		  (goto-char (org-babel-result-end)) (setq beg (point-marker)))
		 ((member "prepend" result-params))) ; already there
		(setq results-switches
		      (if results-switches (concat " " results-switches) ""))
		(let ((wrap
		       (lambda (start finish &optional no-escape no-newlines
				      inline-start inline-finish)
			 (when inline
			   (setq start inline-start)
			   (setq finish inline-finish)
			   (setq no-newlines t))
			 (let ((before-finish (copy-marker end)))
			   (goto-char end)
			   (insert (concat finish (unless no-newlines "\n")))
			   (goto-char beg)
			   (insert (concat start (unless no-newlines "\n")))
			   (unless no-escape
			     (org-escape-code-in-region
			      (min (point) before-finish) before-finish))
			   (goto-char end))))
		      (tabulablep
		       (lambda (r)
			 ;; Non-nil when result R can be turned into
			 ;; a table.
                         (and (proper-list-p r)
			      (cl-every
                               (lambda (e) (or (atom e) (proper-list-p e)))
			       result)))))
		  ;; insert results based on type
		  (cond
		   ;; Do nothing for an empty result.
		   ((null result))
		   ;; Insert a list if preferred.
		   ((member "list" result-params)
		    (insert
		     (org-trim
		      (org-list-to-generic
		       (cons 'unordered
			     (mapcar
			      (lambda (e)
				(list (if (stringp e) e (format "%S" e))))
			      (if (listp result) result
				(split-string result "\n" t))))
		       '(:splicep nil :istart "- " :iend "\n")))
		     "\n"))
		   ;; Try hard to print RESULT as a table.  Give up if
		   ;; it contains an improper list.
		   ((funcall tabulablep result)
		    (goto-char beg)
		    (insert (concat (orgtbl-to-orgtbl
				     (if (cl-every
					  (lambda (e)
					    (or (eq e 'hline) (listp e)))
					  result)
					 result
				       (list result))
				     nil)
				    "\n"))
		    (goto-char beg)
		    (when (org-at-table-p) (org-table-align))
		    (goto-char (org-table-end)))
		   ;; Print verbatim a list that cannot be turned into
		   ;; a table.
		   ((listp result) (insert (format "%s\n" result)))
		   ((member "file" result-params)
		    (when inline
		      (setq result (org-macro-escape-arguments result)))
		    (insert result))
		   ((and inline (not (member "raw" result-params)))
		    (insert (org-macro-escape-arguments
			     (org-babel-chomp result "\n"))))
		   (t (goto-char beg) (insert result)))
		  (setq end (copy-marker (point) t))
		  ;; Possibly wrap result.
		  (el-patch-swap
                    (cond
		     ((assq :wrap (nth 2 info))
		      (let* ((full (or (cdr (assq :wrap (nth 2 info))) "results"))
			     (split (split-string full))
			     (type (car split))
			     (opening-line (concat "#+begin_" full))
			     (closing-line (concat "#+end_" type)))
		        (cond
		         ;; Escape contents from "export" wrap.  Wrap
		         ;; inline results within an export snippet with
		         ;; appropriate value.
		         ((eq t (compare-strings type nil nil "export" nil nil t))
			  (let ((backend (pcase split
					   (`(,_) "none")
					   (`(,_ ,b . ,_) b))))
			    (funcall wrap
				     opening-line closing-line
				     nil nil
				     (format "{{{results(@@%s:"
					     backend) "@@)}}}")))
		         ;; Escape contents from "example" wrap.  Mark
		         ;; inline results as verbatim.
		         ((eq t (compare-strings type nil nil "example" nil nil t))
			  (funcall wrap
				   opening-line closing-line
				   nil nil
				   "{{{results(=" "=)}}}"))
		         ;; Escape contents from "src" wrap.  Mark
		         ;; inline results as inline source code.
		         ((eq t (compare-strings type nil nil "src" nil nil t))
			  (let ((inline-open
			         (pcase split
				   (`(,_)
				    "{{{results(src_none{")
				   (`(,_ ,language)
				    (format "{{{results(src_%s{" language))
				   (`(,_ ,language . ,rest)
				    (let ((r (mapconcat #'identity rest " ")))
				      (format "{{{results(src_%s[%s]{"
					      language r))))))
			    (funcall wrap
				     opening-line closing-line
				     nil nil
				     inline-open "})}}}")))
		         ;; Do not escape contents in non-verbatim
		         ;; blocks.  Return plain inline results.
		         (t
			  (funcall wrap
				   opening-line closing-line
				   t nil
				   "{{{results(" ")}}}")))))
		     ((member "html" result-params)
		      (funcall wrap "#+begin_export html" "#+end_export" nil nil
			       "{{{results(@@html:" "@@)}}}"))
		     ((member "latex" result-params)
		      (funcall wrap "#+begin_export latex" "#+end_export" nil nil
			       "{{{results(@@latex:" "@@)}}}"))
		     ((member "org" result-params)
		      (goto-char beg) (when (org-at-table-p) (org-cycle))
		      (funcall wrap "#+begin_src org" "#+end_src" nil nil
			       "{{{results(src_org{" "})}}}"))
		     ((member "code" result-params)
		      (let ((lang (or lang "none")))
		        (funcall wrap (format "#+begin_src %s%s" lang results-switches)
			         "#+end_src" nil nil
			         (format "{{{results(src_%s[%s]{" lang results-switches)
			         "})}}}")))
		     ((member "raw" result-params)
		      (goto-char beg) (when (org-at-table-p) (org-cycle)))
		     ((or (member "drawer" result-params)
			  ;; Stay backward compatible with <7.9.2
			  (member "wrap" result-params))
		      (goto-char beg) (when (org-at-table-p) (org-cycle))
		      (funcall wrap ":results:" ":end:" 'no-escape nil
			       "{{{results(" ")}}}"))
		     ((and inline (member "file" result-params))
		      (funcall wrap nil nil nil nil "{{{results(" ")}}}"))
		     ((and (not (funcall tabulablep result))
			   (not (member "file" result-params)))
		      (let ((org-babel-inline-result-wrap
			     ;; Hard code {{{results(...)}}} on top of
			     ;; customization.
			     (format "{{{results(%s)}}}"
				     org-babel-inline-result-wrap)))
		        (org-babel-examplify-region
		         beg end results-switches inline))))
                  (let ((formats (copy-tree mirage/org-babel-result-wrap-formats)))
                    (eval (add-to-list 'formats 'cond)))))
                ;; Possibly indent results in par with #+results line.
		(when (and (not inline) (numberp indent) (> indent 0)
			   ;; In this case `table-align' does the work
			   ;; for us.
			   (not (and (listp result)
				     (member "append" result-params))))
		  (indent-rigidly beg end indent))
                (let ((time-info
                       ;; Only show the time when something other than
                       ;; 0s will be shown, i.e. check if the time is at
                       ;; least half of the displayed precision.
                       (if (and exec-time (> (float-time exec-time) 0.05))
                           (format " (took %.1fs)" (float-time exec-time))
                         "")))
                  (if (null result)
                      (if (member "value" result-params)
                          (message "Code block returned no value%s." time-info)
                        (message "Code block produced no output%s." time-info))
                    (message "Code block evaluation complete%s." time-info))))
	    (set-marker end nil)
	    (when outside-scope (narrow-to-region visible-beg visible-end))
	    (set-marker visible-beg nil)
	    (set-marker visible-end nil)))))))

#+end_src

